[
  {
    "objectID": "MonteCarlo.html",
    "href": "MonteCarlo.html",
    "title": "Advanced Monte Carlo",
    "section": "",
    "text": "Function\n\n\"SOC.function\"<-\n  function(SOC.ref = 80, SOC.ref.sd = 36, area = 56890, area.sd = 2844.5, expert.file = \"name\",\n           cult.beta.file = \"name\", mgmt.beta.file = \"name\", input.beta.file = \"name\", \n           cult.cov.file = \"name\", mgmt.cov.file = \"name\", input.cov.file = \"name\", \n           x.cult.file = \"name\", x.mgmt.file = \"name\", x.input.file = \"name\", nexpert = 9, \n           ncases = 6, strata = 1, d = 20, nreps = 10000, iseed = 230984, return.option=1, EF.ft = 1, EF.med.input = 1)\n# Script developed by M. Carlson\n# Originally developed: 9/27/2022\n# Last updated: \n# script estimates historical Soil Carbon \n# based on LME model that estimates emission factors\n#\n##### Arguments\n# reference soil carbon           from volcanic soils and warm temperate, moist\n# ref soil carbon uncertainty     + or - 90%\n# cropland area                   in ha\n# cropland area uncertainty       + or - 5%\n# d                               20 years\n# input data                      Expert data proportions\n# beta                            R object with betas from LME model\n# cov.beta                        R object with covariance matrix for betas from LME model\n# nreps                           Number of Monte Carlo simulations\n# iseed                           Initial seed for random draws\n# return.option            \n#\n##    \n##### Begin script\n  {\n##### Set seed\n    set.seed(iseed)\n    \n####### Import files\n    input.data<-read.csv(file = expert.file, header = F)\n    \n    cult.beta<-read.csv(file = cult.beta.file, header = F)\n    mgmt.beta<-read.csv(file = mgmt.beta.file, header = F)\n    input.beta<-read.csv(file = input.beta.file, header = F)\n    \n    cult.cov<-read.csv(file = cult.cov.file, header = F)\n    mgmt.cov<-read.csv(file = mgmt.cov.file, header = F)\n    input.cov<-read.csv(file = input.cov.file, header = F)\n    \n    x.cult<-read.csv(file = x.cult.file, header = F)\n    x.mgmt<-read.csv(file = x.mgmt.file, header = F)\n    x.input<-read.csv(file = x.input.file, header = F)\n    \n# ----------Probabilistic calculation ---------------\n\n####### Monte Carlo replicates\n    \n    ### simulate nreps of SOC ref\n    SOC.ref.sim<-rnorm(nreps, mean = SOC.ref, sd = SOC.ref.sd) \n    SOC.ref.sim<-as.matrix(t(SOC.ref.sim))\n    \n    # check that reps are inside 2 sd\n    check.soc.ref<-(SOC.ref.sim >= SOC.ref-(2*SOC.ref.sd)) &\n                   (SOC.ref.sim <= SOC.ref+(2*SOC.ref.sd))\n    if(!check.soc.ref){\n      stop(\"Warning: Simulated soil carbon reference is outside of expected range.\")\n    }\n    \n    ### simulate nreps of area\n    area.sim<-rnorm(nreps, mean = area, sd = area.sd) \n    \n    # check\n    check.area<-(area.sim >= area-(2*area.sd)) &\n                (area.sim <= area+(2*area.sd))\n    if(!check.area){\n      stop(\"Warning: Simulated area is outside of expected range.\")\n    }\n    \n    ### sample input data (2005 and 2020 together)\n    expert.draw<-input.data[sample(ncol(input.data), \n                                     size = nreps, replace = TRUE)]\n    # check\n    check.expert<-sum(expert.draw[,1]) == (2*strata)\n    if(!check.expert){\n      stop(\"Problem with expert proportions not summing to 100%\")\n    }\n    \n    # Combine area and expert proportion\n    area.prop.comb<-sweep(expert.draw, MARGIN=2, area.sim, `*`)\n    \n    # Check\n    check.prop.area<-area.prop.comb<=area\n    if(!check.prop.area){\n      stop(\"Proportion of area is not accurate\")\n    }\n    \n######## Emission Factor draws\n    \n    # turn into vectors\n    \n    cult.beta<-c(cult.beta[,1])\n    mgmt.beta<-c(mgmt.beta[,1])\n    input.beta<-c(input.beta[,1])\n    \n    x.cult<-c(x.cult[,1])\n    \n    x.mgmt.w.r<-c(x.mgmt[,1])\n    x.mgmt.w.n<-c(x.mgmt[,2])\n    x.mgmt.d.r<-c(x.mgmt[,3])\n    x.mgmt.d.n<-c(x.mgmt[,4])\n    \n    x.input.w.l<-c(x.input[,1])\n    x.input.w.h<-c(x.input[,2])\n    x.input.c.l<-c(x.input[,3])\n    x.input.c.h<-c(x.input[,4])\n    \n    # determine number of parameters\n    numpar.cult<-length(cult.beta)\n    numpar.mgmt<-length(mgmt.beta)\n    numpar.input<-length(input.beta)\n\n    # compute Choleski decomposition\n    decomp.cult<-t(chol(cult.cov))\n    decomp.mgmt<-t(chol(mgmt.cov))\n    decomp.input<-t(chol(input.cov))\n    \n    # generate random normals\n    r.cult<-matrix(rnorm(nreps*numpar.cult), numpar.cult, nreps)\n    r.mgmt<-matrix(rnorm(nreps*numpar.mgmt), numpar.mgmt, nreps)\n    r.input<-matrix(rnorm(nreps*numpar.input), numpar.input, nreps)\n    \n    # produce simulated betas\n    cult.sim.beta<-(decomp.cult%*%r.cult)+cult.beta\n    mgmt.sim.beta<-(decomp.mgmt%*%r.mgmt)+mgmt.beta\n    input.sim.beta<-(decomp.input%*%r.input)+input.beta\n    \n    \n######## Emission factors\n    \n    # cultivation\n    x.cult.beta<-sweep(cult.sim.beta, MARGIN=1, x.cult, `*`)\n    ef.cult<-apply(x.cult.beta[,1:nreps], 2, sum)\n    ef.cult<-as.matrix(t(ef.cult))\n    \n    # management\n    x.mgmt.w.r.beta<-sweep(mgmt.sim.beta, MARGIN=1, x.mgmt.w.r, `*`)\n    ef.mgmt.w.r<-apply(x.mgmt.w.r.beta[,1:nreps], 2, sum)\n    ef.mgmt.w.r<-as.matrix(t(ef.mgmt.w.r))\n    \n    x.mgmt.w.n.beta<-sweep(mgmt.sim.beta, MARGIN=1, x.mgmt.w.n, `*`)\n    ef.mgmt.w.n<-apply(x.mgmt.w.n.beta, 2, sum)\n    ef.mgmt.w.n<-as.matrix(t(ef.mgmt.w.n))\n    \n    x.mgmt.d.r.beta<-sweep(mgmt.sim.beta, MARGIN=1, x.mgmt.d.r, `*`)\n    ef.mgmt.d.r<-apply(x.mgmt.d.r.beta[,1:nreps], 2, sum)\n    ef.mgmt.d.r<-as.matrix(t(ef.mgmt.d.r))\n    \n    x.mgmt.d.n.beta<-sweep(mgmt.sim.beta, MARGIN=1, x.mgmt.d.n, `*`)\n    ef.mgmt.d.n<-apply(x.mgmt.d.n.beta[,1:nreps], 2, sum)\n    ef.mgmt.d.n<-as.matrix(t(ef.mgmt.d.n))\n    \n    # input\n    x.input.w.l.beta<-sweep(input.sim.beta, MARGIN=1, x.input.w.l, `*`)\n    ef.input.w.l<-apply(x.input.w.l.beta[,1:nreps], 2, sum)\n    ef.input.w.l<-as.matrix(t(ef.input.w.l))\n    \n    x.input.w.h.beta<-sweep(input.sim.beta, MARGIN=1, x.input.w.h, `*`)\n    ef.input.w.h<-apply(x.input.w.h.beta[,1:nreps], 2, sum)\n    ef.input.w.h<-as.matrix(t(ef.input.w.h))\n    \n    x.input.c.l.beta<-sweep(input.sim.beta, MARGIN=1, x.input.c.l, `*`)\n    ef.input.c.l<-apply(x.input.c.l.beta[,1:nreps], 2, sum)\n    ef.input.c.l<-as.matrix(t(ef.input.c.l))\n    \n    x.input.c.h.beta<-sweep(input.sim.beta, MARGIN=1, x.input.c.h, `*`)\n    ef.input.c.h<-apply(x.input.c.h.beta[,1:nreps], 2, sum)\n    ef.input.c.h<-as.matrix(t(ef.input.c.h))\n    \n\n####### -------------- Calculations -------------------------\n\n    ### Low input full till\n    SOC.l.f<-matrix(0, nrow = 1, ncol = nreps)\n    for (s in (1:nreps)) {\n      SOC.l.f[,s]<-((SOC.ref.sim[,s]*EF.ft*ef.cult[,s]*ef.input.w.l[,s]*area.prop.comb[7,s])-\n                    (SOC.ref.sim[,s]*EF.ft*ef.cult[,s]*ef.input.w.l[,s]*area.prop.comb[1,s]))/d\n    }\n    \n    ### Low input no till\n    SOC.l.n<-matrix(0, nrow = 1, ncol = nreps)\n    for (p in (1:nreps)) {\n      SOC.l.n[,p]<-((SOC.ref.sim[,p]*ef.cult[,p]*ef.input.w.l[,p]*ef.mgmt.w.n[,p]*area.prop.comb[8,p])-\n                    (SOC.ref.sim[,p]*ef.cult[,p]*ef.input.w.l[,p]*ef.mgmt.w.n[,p]*area.prop.comb[2,p]))/d\n    }\n    \n    ### Medium input full till\n    SOC.m.f<-matrix(0, nrow = 1, ncol = nreps)\n    for (q in (1:nreps)) {\n      SOC.m.f[,q]<-((SOC.ref.sim[,q]*EF.ft*ef.cult[,q]*EF.med.input*area.prop.comb[9,q])-\n                    (SOC.ref.sim[,q]*EF.ft*ef.cult[,q]*EF.med.input*area.prop.comb[3,q]))/d\n    }\n    \n    ### Medium input no till\n    SOC.m.n<-matrix(0, nrow = 1, ncol = nreps)\n    for (u in (1:nreps)) {\n      SOC.m.n[,u]<-((SOC.ref.sim[,u]*ef.cult[,u]*EF.med.input*ef.mgmt.w.n[,u]*area.prop.comb[10,u])-\n                    (SOC.ref.sim[,u]*ef.cult[,u]*EF.med.input*ef.mgmt.w.n[,u]*area.prop.comb[4,u]))/d\n    }\n    \n    ### High input full till\n    SOC.h.f<-matrix(0, nrow = 1, ncol = nreps)\n    for (v in (1:nreps)) {\n      SOC.h.f[,v]<-((SOC.ref.sim[,v]*EF.ft*ef.cult[,v]*ef.input.w.h[,v]*area.prop.comb[11,v])-\n                    (SOC.ref.sim[,v]*EF.ft*ef.cult[,v]*ef.input.w.h[,v]*area.prop.comb[5,v]))/d\n    }\n    \n    ### High input no till\n    SOC.h.n<-matrix(0, nrow = 1, ncol = nreps)\n    for (x in (1:nreps)) {\n      SOC.h.n[,x]<-((SOC.ref.sim[,x]*ef.cult[,x]*ef.input.w.h[,x]*ef.mgmt.w.n[,x]*area.prop.comb[12,x])-\n                    (SOC.ref.sim[,x]*ef.cult[,x]*ef.input.w.h[,x]*ef.mgmt.w.n[,x]*area.prop.comb[6,x]))/d\n    }\n    \n####### Total results\n    SOC.total<-matrix(0, nrow = 1, ncol = nreps)\n    for (t in (1:nreps)) {\n      SOC.total[,t]<-SOC.l.f[,t]+SOC.l.n[,t]+SOC.m.f[,t]+SOC.m.n[,t]+SOC.h.f[,t]+SOC.h.n[,t]\n    }\n    \n    \n####### Mean and Confidence Intervals    \n    results<-matrix(0, nrow = 1, ncol = 3)\n    results[,1]<-mean(SOC.total)\n    q<-quantile(SOC.total, probs = c(.025,.975))\n    results[,2]<-q[1]\n    results[,3]<-q[2]\n    \n######## -------------- Return options------------------------------\n    \n    if(return.option == 1){\n      return(list(\"Mean change in mineral soils C stock for Island X between\n                  2005 and 2020 (C tonnes/year)\" = results[,1], \"2.5 percentile\"\n                  = results[,2], \"97.5 percentile\" = results[,3]))\n    }\n    \n    if(return.option == 2){\n      return(hist(x=SOC.total, main = \"Simulated change in soil organic carbon.\"))\n    }\n  \n####### End script    \n  }\n\n\n\nFunction Call\n\nInventory<-SOC.function(expert.file = \"CropExpertProp.csv\", cult.beta.file = \"cult.beta.csv\",\n                        mgmt.beta.file = \"mgmt.beta.csv\", input.beta.file = \"input.beta.csv\", \n                        cult.cov.file = \"cult.cov.csv\", mgmt.cov.file = \"mgmt.cov.csv\",\n                        input.cov.file = \"input.cov.csv\", x.cult.file = \"x.cult.csv\",\n                        x.mgmt.file = \"x.mgmt.csv\", x.input.file = \"x.input.csv\", \n                        return.option=1)\n\nInventory2<-SOC.function(expert.file = \"CropExpertProp.csv\", cult.beta.file = \"cult.beta.csv\",\n                        mgmt.beta.file = \"mgmt.beta.csv\", input.beta.file = \"input.beta.csv\", \n                        cult.cov.file = \"cult.cov.csv\", mgmt.cov.file = \"mgmt.cov.csv\",\n                        input.cov.file = \"input.cov.csv\", x.cult.file = \"x.cult.csv\",\n                        x.mgmt.file = \"x.mgmt.csv\", x.input.file = \"x.input.csv\", \n                        return.option=2)\n  \n\nProjection2005.2025<-SOC.function(expert.file = \"Crop2025.csv\", cult.beta.file = \"cult.beta.csv\",\n                                    mgmt.beta.file = \"mgmt.beta.csv\", input.beta.file = \"input.beta.csv\", \n                                    cult.cov.file = \"cult.cov.csv\", mgmt.cov.file = \"mgmt.cov.csv\",\n                                    input.cov.file = \"input.cov.csv\", x.cult.file = \"x.cult.csv\",\n                                    x.mgmt.file = \"x.mgmt.csv\", x.input.file = \"x.input.csv\", \n                                    return.option=1)\n\nProjection2025.2040<-SOC.function(expert.file = \"Crop2040.csv\", cult.beta.file = \"cult.beta.csv\",\n                         mgmt.beta.file = \"mgmt.beta.csv\", input.beta.file = \"input.beta.csv\", \n                         cult.cov.file = \"cult.cov.csv\", mgmt.cov.file = \"mgmt.cov.csv\",\n                         input.cov.file = \"input.cov.csv\", x.cult.file = \"x.cult.csv\",\n                         x.mgmt.file = \"x.mgmt.csv\", x.input.file = \"x.input.csv\", \n                         return.option=1)"
  },
  {
    "objectID": "EmissionFactors.html",
    "href": "EmissionFactors.html",
    "title": "Estimate Emission Factors",
    "section": "",
    "text": "####### Libraries\nlibrary(nlme)\nlibrary(ggplot2)\n\n\n####### Data\n\nCultivation<-read.csv(\"SoilCCult.csv\")\nManagement<-read.csv(\"SoilCManagement.csv\")\nInput<-read.csv(\"SoilCInput.csv\")\n\n\n# ------------------------ Cultivation-------------------------------\n#Data Visualization\nggplot(Cultivation, aes(years))+\n  geom_histogram()\nggplot(Cultivation, aes(dep1))+\n  geom_histogram()\nggplot(Cultivation, aes(dep2))+\n  geom_histogram()\nggplot(Cultivation, aes(cult.stock))+\n  geom_histogram()\nggplot(Cultivation, aes(ch.cstock))+\n  geom_histogram()\nggplot(Cultivation, aes(nat.stock))+\n  geom_histogram()\nggplot(Cultivation, aes(x = ipcc.temp))+\n  geom_bar()\nggplot(Cultivation, aes(x = ipcc.soil))+\n  geom_bar()\nggplot(Cultivation, aes(x = ipcc.prec))+\n  geom_bar()\nggplot(Cultivation, aes(x = aquic))+\n  geom_bar()\n\n####### model\ncor(Management[c(\"years\", \"years2\", \"dep1\", \"dep2\")])\n\ntest.fit<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ipcc.soil+ipcc.prec,\n              random=~1|ran.exp/ran.yrexp,data=Cultivation,method=\"ML\",\n              na.action=na.omit)\nplot(test.fit)\nqqnorm(test.fit)\n\ntest.fit1<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ipcc.soil+ipcc.prec,\n              random=~1|ran.exp/ran.yrexp,data=Cultivation,method=\"ML\",\n              na.action=na.omit)\n\n# AIC Go up by two when removing variable (down by 2 when adding)\nsummary(test.fit1)\n\n# remove soil\ntest.fit1<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ipcc.prec,\n               random=~1|ran.exp/ran.yrexp,data=Cultivation,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit1)\n\n\n# Best model\ncult.fit<-lme(ch.cstock~years+years2+dep1+dep2,\n               random=~1|ran.exp/ran.yrexp,data=Cultivation,method=\"REML\",\n               na.action=na.omit)\nsummary(cult.fit)\n\n# pdf\nfixed.cult<-fixed.effects(cult.fit)\ncult.cov<-cult.fit$varFix\n\nfixed.cult\ncult.cov\n\nx.cult<-c(1, 75, 5625, 15, 300)\nt(x.cult)%*%fixed.cult\nv.cult<-(t(x.cult)%*%cult.cov%*%x.cult)\nsqrt(v.cult)\n\n\n# ------------------------ Input -------------------------------\n# Data Visualization\nggplot(Input, aes(years))+\n  geom_histogram()\nggplot(Input, aes(dep1))+\n  geom_histogram()\nggplot(Input, aes(dep2))+\n  geom_histogram()\nggplot(Input, aes(con.stock))+\n  geom_histogram()\nggplot(Input, aes(ch.cstock))+\n  geom_histogram()\nggplot(Input, aes(tr.stock))+\n  geom_histogram()\nggplot(Input, aes(x = ipcc.temp))+\n  geom_bar()\nggplot(Input, aes(x = ipcc.soil))+\n  geom_bar()\nggplot(Input, aes(x = ipcc.pre))+\n  geom_bar()\nggplot(Input, aes(x = ch.inp))+\n  geom_bar()\nggplot(Input, aes(x = aquic))+\n  geom_bar()\n\n\n####### model\ncor(Input[c(\"years\", \"years2\", \"dep1\", \"dep2\")])\n\ntest.fit2<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ipcc.pre+ch.inp,\n              random=~1|ran.exp/ran.yrexp,data=Input,method=\"ML\",\n              na.action=na.omit)\nplot(test.fit2)\nqqnorm(test.fit2)\n\nsummary(test.fit2)\n\n# remove precip\ntest.fit2<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ch.inp,\n               random=~1|ran.exp/ran.yrexp,data=Input,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit2)\n\n# remove temp (didn't go down enough)\ntest.fit2<-lme(ch.cstock~years+years2+dep1+dep2+ch.inp,\n               random=~1|ran.exp/ran.yrexp,data=Input,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit2)\n\n#### Best fit model\ninput.fit<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ch.inp,\n               random=~1|ran.exp/ran.yrexp,data=Input,method=\"REML\",\n               na.action=na.omit)\nsummary(input.fit)\n\n# pdf\nfixed.input<-fixed.effects(input.fit)\ninput.cov<-input.fit$varFix\n\nfixed.input\n\nwarm.low<-c(1, 20, 400, 15, 300, 1, 1)\nwarm.high<-c(1, 20, 400, 15, 300, 1, 0)\ncool.low<-c(1, 20, 400, 15, 300, 0, 1)\ncool.high<-c(1, 20, 400, 15, 300, 0, 0)\n\n#Estimates\nt(warm.low)%*%fixed.input\nt(warm.high)%*%fixed.input\nt(cool.low)%*%fixed.input\nt(cool.high)%*%fixed.input\n\n# variance\nv.warm.low<-(t(warm.low)%*%input.cov%*%warm.low)\nv.warm.high<-(t(warm.high)%*%input.cov%*%warm.high)\nv.cool.low<-(t(cool.low)%*%input.cov%*%cool.low)\nv.cool.high<-(t(cool.high)%*%input.cov%*%cool.high)\n\n# standard deviation\nsqrt(v.warm.low)\nsqrt(v.warm.high)\nsqrt(v.cool.low)\nsqrt(v.cool.high)\n\n\n# ---------------------------- Management --------------------------------\n# Data Visualization\nggplot(Management, aes(years))+\n  geom_histogram()\nggplot(Management, aes(dep1))+\n  geom_histogram()\nggplot(Management, aes(dep2))+\n  geom_histogram()\nggplot(Management, aes(con.stock))+\n  geom_histogram()\nggplot(Management, aes(ch.cstock))+\n  geom_histogram()\nggplot(Management, aes(tr.stock))+\n  geom_histogram()\nggplot(Management, aes(x = ipcc.temp))+\n  geom_bar()\nggplot(Management, aes(x = ipcc.soil))+\n  geom_bar()\nggplot(Management, aes(x = ipcc.pre))+\n  geom_bar()\nggplot(Management, aes(x = ch.till))+\n  geom_bar()\nggplot(Management, aes(x = aquic))+\n  geom_bar()\n\n\n####### model\ncor(Management[c(\"years\", \"years2\", \"dep1\", \"dep2\")])\n\ntest.fit3<-lme(ch.cstock~years2+ipcc.temp+ipcc.soil+ipcc.pre+years+dep1+dep2+aquic+ch.till,\n               random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n               na.action=na.omit)\nplot(test.fit3)\nqqnorm(test.fit3)\n\n\n# AIC Go up by two when removing variable (down by 2 when adding)\nsummary(test.fit3)\n\n# remove aquic\ntest.fit3<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ipcc.soil+ipcc.pre+ch.till,\n               random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit3)\n\n# remove soil\ntest.fit3<-lme(ch.cstock~years+years2+ipcc.pre+ipcc.temp+dep1+dep2+ch.till,\n               random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit3)\n\n# remove precip (keep it in)\ntest.fit3<-lme(ch.cstock~years+years2+ipcc.temp+dep1+dep2+ch.till,\n               random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit3)\n\n# remove temp\ntest.fit3<-lme(ch.cstock~years+years2+ipcc.pre+dep1+dep2+ch.till,\n               random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit3)\n\n# Best model\nmgmt.fit<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.pre+ch.till,\n                         random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n                         na.action=na.omit)\nsummary(mgmt.fit)\n\n\n# pdf\nfixed.mgmt<-fixed.effects(mgmt.fit)\nmgmt.cov<-mgmt.fit$varFix\n\nwet.rt<-c(1, 20, 400, 15, 300, 1, 1)\nwet.nt<-c(1, 20, 400, 15, 300, 1, 0)\ndry.rt<-c(1, 20, 400, 15, 300, 0, 1)\ndry.nt<-c(1, 20, 400, 15, 300, 0, 0)\n\n#Estimates\nt(wet.rt)%*%fixed.mgmt\nt(wet.nt)%*%fixed.mgmt\nt(dry.rt)%*%fixed.mgmt\nt(dry.nt)%*%fixed.mgmt\n\n# variance\nv.rt.wet<-(t(wet.rt)%*%mgmt.cov%*%wet.rt)\nv.nt.wet<-(t(wet.nt)%*%mgmt.cov%*%wet.nt)\nv.rt.dry<-(t(dry.rt)%*%mgmt.cov%*%dry.rt)\nv.nt.dry<-(t(dry.nt)%*%mgmt.cov%*%dry.nt)\n\n# standard deviation\nsqrt(v.rt.wet)\nsqrt(v.rt.dry)\nsqrt(v.nt.wet)\nsqrt(v.nt.dry)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Greenhouse Gas Accounting Portfolio",
    "section": "",
    "text": "Talk about myself\n------------------------------------------\n\n\nMasters in Ecosystem Science and Sustainability | Colorado State University 2021-2023\nBachelors in Environmental Studies | Kenyon College 2015 - 2019\n------------------------------------------"
  },
  {
    "objectID": "UreaEmissions.html",
    "href": "UreaEmissions.html",
    "title": "Urea Fertilization Emissions",
    "section": "",
    "text": "Function\nThis function was developed by M. Carlson\nOriginally developed: 8/25/2022\nLast updated:\nData used in this function is in\n\n\"Urea.Fert.Emisssions\"<-\n  function(input.file = \"name\", nyears = 31, states = 50, EF = .2, EF.min = .1,\n           EF.max = .2, nreps = 10000, iseed = 213456, return.option = 1)\n    # Input data converted from N to Urea\n    \n##### Begin script\n  {\n    # Seed seed\n    set.seed(iseed)\n    \n    ####### Import files\n    input.data<-read.csv(file = input.file)\n    \n    ####### Check Validity of Input Data\n    # Numeric\n    for (n in 1:(nyears*2)) {\n      input.data[,n+1]<-as.numeric(input.data[,n+1])\n    }\n    \n    # Urea Amounts\n    for (y in (1:nyears)){\n      for (t in (1:states)){\n    check.urea<-input.data[t,y+1]>0\n    if(!check.urea){stop(\"Error: Data is zero or negative.\")}\n      }\n    }\n    \n    # SD\n    for (y in (1:nyears)){\n      for (t in (1:states)){\n        check.sd<-input.data[t,y+1+nyears]>0\n        if(!check.sd){stop(\"Error: Data is zero or negative.\")}\n      }\n    }\n    \n    \n    ######## Deterministic results\n    Deterministic.CO2C<-matrix(0, nrow = states, ncol = nyears)\n    for(y in (1:nyears)){\n      for(d in (1:states)){\n        Deterministic.CO2C[d,y]<-(input.data[d,y+1]*EF)\n      }\n    }\n    \n    ##\n    Deterministic.CO2C.total<-apply(Deterministic.CO2C, MAR = 2, FUN = \"sum\")\n    Deterministic.CO2.total<-(Deterministic.CO2C.total*(44/12)/10^6)\n    Deterministic.CO2<-Deterministic.CO2C*(44/12)/10^6\n      \n    ######## Sim nreps \n    # EF\n    EF.sim<-rtriangle(nreps, a = EF.min, b = EF.max, c = EF)  \n    \n    \n    q.factor<-quantile(EF.sim, probs = c(.05,1))\n    down.factor<-q.factor[1]\n    up.factor<-q.factor[2]\n    \n    # Urea\n    urea.sim<-matrix(0, nrow = states*nyears, ncol = nreps)\n    for (y in (1:nyears)) {\n      for (t in (1:states)) {\n        urea.sim[t+(y-1)*50,]<-rnorm(n = nreps, mean = input.data[t, y+1], \n                                sd = input.data[t, y+1+nyears])\n      }\n    }\n    \n    ######## Probabilistic results\n    Probabilistic.CO2C<-matrix(0, nrow = states*nyears, ncol = nreps)\n    for (y in 1:nyears) {\n      for (s in 1:states) {\n        Probabilistic.CO2C[s+(states*(y-1)),]<-EF.sim*urea.sim[s+(states*(y-1)),]\n      }\n    }\n    \n    \n    # find mode\n    mode<-function(x){which.max(tabulate(x))}\n  \n    results.mode<-apply(Probabilistic.CO2C, 1, mode)\n    results.mode<-as.data.frame(results.mode)\n    \n    \n    \n    # Convert to Gg CO2\n    results.mode<-(results.mode*(44/12)/10^6)\n\n    # Make into readable df\n    State<-rep(c(\"Alabama\",\"Alaska\",\"Arizona\",\"Arkansas\",\"California\",\"Colorado\",\n             \"Connecticut\",\"Delaware\",\"Florida\",\"Georgia\",\"Hawaii\",\"Idaho\",\"Illinois\",\n             \"Indiana\",\"Iowa\",\"Kansas\",\"Kentucky\",\"Louisiana\",\"Maine\",\"Maryland\",\"Massachusetts\",\n             \"Michigan\",\"Minnesota\",\"Mississippi\",\"Missouri\",\"Montana\",\"Nebraska\",\"Nevada\",\n             \"New Hampsire\",\"New Jersey\",\"New Mexico\",\"New York\",\"North Carolina\",\"North Dakota\",\n             \"Ohio\",\"Oklahoma\",\"Oregon\",\"Pennsylvania\",\"Rhode Island\",\"South Carolina\",\n             \"South Dakota\",\"Tennessee\",\"Texas\",\"Utah\",\"Vermont\",\"Virginia\",\"Washington\",\"West Virginia\",\n             \"Wisconsin\",\"Wyoming\"),times=nyears)\n    results.mode$State<-data.frame(State)\n\n    newinput<-input.data[,1:32]\n    newinput<-newinput%>%\n      pivot_longer(!State, names_to = \"Year\", values_to = \"Urea\")\n    newinput<-newinput[order(newinput$Year),]\n    results.mode$xYear<-newinput$Year\n    \n    results.mode$emissions<-results.mode$results.mode\n    results.mode<-results.mode[,2:4]\n    \n    Probabilistic.CO2<-results.mode%>%\n      pivot_wider(names_from = \"xYear\", values_from = \"emissions\")\n    \n  mode2<-function(v, n=2){\n    v<-round(v,n)\n    u<-unique(v)\n    u[which.max(tabulate(match(v,u)))]\n  }\n    \n    \nProb.CO2C.state<-matrix(0, nrow = states*nyears, ncol = 3)\nfor (y in (1:(nyears*states))) {\n  Prob.CO2C.state[y,1]<-mode2(Probabilistic.CO2C[y,])\n  q<-quantile(Probabilistic.CO2C[y,], probs = c(.05,1))\n  Prob.CO2C.state[y,2]<-q[1]\n  Prob.CO2C.state[y,3]<-q[2]\n}\n\nProb.CO2.state<-(Prob.CO2C.state*(44/12)/10^6)\ncolnames(Prob.CO2.state)<-c(\"Mode\", \"5 Percentile\", \"100 Percentile\")\nrownames(Prob.CO2.state)<-State\nProb.CO2.state<-as.data.frame(Prob.CO2.state)\nProb.CO2.state$xYear<-newinput$Year\n\n  \n  \n    ##### Total probabilistic  per year\n    \n    Probabilistic.CO2C.total.US<-matrix(0, nrow = nyears, ncol = nreps)\n    for (y in (1:nyears)){\n     Probabilistic.CO2C.total.US[y,]<-apply(Probabilistic.CO2C[(1+(50*(y-1))):(50+(50*(y-1))),], MARG = 2, FUN = \"sum\")\n    }\n    \n    Total.emissions.results.CO2C<-matrix(0, nrow = nyears, ncol = 3)\n    for (y in (1:nyears)) {\n     Total.emissions.results.CO2C[y,1]<-mode2(Probabilistic.CO2C.total.US[y,1]) \n     q<-quantile(Probabilistic.CO2C.total.US[y,1], probs = c(.05,1))\n     Total.emissions.results.CO2C[y,2]<-q[1]\n     Total.emissions.results.CO2C[y,3]<-q[2]\n    }\n    \n    Total.emissions.results<-(Total.emissions.results.CO2C*(44/12)/10^6)\n    colnames(Total.emissions.results)<-c(\"Mode\", \"5 Percentile\", \"100 Percentile\")\n    rownames(Total.emissions.results)<-c(1990:2020)\n    \n    ######## Check that probabilistic is less than or equal to deterministic\n    # per state per year\n   # for (y in (1:nyears)){\n   #   for (t in (1:states)){\n    #    check.results<-Probabilistic.CO2[t,y]<=Deterministic.CO2[t,y]\n     #   if(!check.results){stop(\"Error: Probabilistic emissions are too high.\")}}}\n    \n    # per country per year\n    #for (y in (1:nyears)){\n     #   check.results.total<-Probabilistic.CO2.total[,y]<=Deterministic.CO2.total[,y]\n      #  if(!check.results.total){stop(\"Error: Total probabilistic emissions for the \n       #                               country are too high.\")}}\n    \n    ######## Return Statement\n    if(return.option == 1){\n      return(Total.emissions.results)\n    }\n    if(return.option == 2){\n      return(Prob.CO2.state)\n    }\n    if(return.option == 3){\n      return(Deterministic.CO2)\n    }\n    \n    \n###### End script\n    }\n\n\n\nResult Exploration\n\nTotal.Emissions.year<-Urea.Fert.Emisssions(input.file = \"data/US-Urea1990-2020.csv\", return.option = 1)\nhead(Total.Emissions.year)\n\n         Mode 5 Percentile 100 Percentile\n1990 4.184332     4.184332       4.184332\n1991 4.011988     4.011988       4.011988\n1992 4.292598     4.292598       4.292598\n1993 4.571429     4.571429       4.571429\n1994 4.641019     4.641019       4.641019\n1995 4.588808     4.588808       4.588808"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "MineralFert.html",
    "href": "MineralFert.html",
    "title": "Mineral Fertilization Emissions",
    "section": "",
    "text": "Model Fit\n\n# Regression analysis using linear mixed effect model\n# load nlme package\nlibrary(nlme)\n####### Management Factor\n# Read data from csv file\nmanagement.data<-read.csv(\"SoilCManagement.csv\", header = T)\n# Test for correlation in predictor variables\ncor(management.data[, c(\"years\", \"dep1\", \"dep2\")])\n# Fit full model with all variables as main effects for input\ntest.fit<-lme(ch.cstock~ch.till+years+years2+dep1+dep2+moisture+temp,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n# Diagnostic Plots, Residual Plot\nresid<-residuals(test.fit)\nplot(fitted(test.fit), resid)\nabline(0,0)\n# QQ normal plot\nqqnorm(resid)\nqqline(resid)\n# Full model\ntest.fit<-lme(ch.cstock~ch.till+years+years2+dep1+dep2+moisture+temp,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n# Backward stepwise method\n# remove year2\ntest.fit<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture+temp,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n#remove tempwarm\ntest.fit<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n# Testing interactions\ntest.fit<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture+ch.till*years+ch.till*dep1+\n                ch.till*dep2+ch.till*moisture+years*dep1+years*dep2+years*moisture+\n                dep1*moisture+dep2*moisture,\n                random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n                na.action = na.omit)\nsummary(test.fit)\n# remove year and moisture interaction\ntest.fit<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture+ch.till*years+ch.till*dep1+\n                ch.till*dep2+ch.till*moisture+years*dep1+years*dep2+\n                dep1*moisture+dep2*moisture,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n# remove tillage and moisture interaction\ntest.fit<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture+ch.till*years+ch.till*dep1+\n                ch.till*dep2+years*dep1+years*dep2+\n                dep1*moisture+dep2*moisture,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n# final model\ntest.fit.management<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture+ch.till*years+ch.till*dep1+\n                ch.till*dep2+years*dep1+years*dep2+\n                dep1*moisture+dep2*moisture,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"REML\",\n              na.action = na.omit)\nsummary(test.fit.management)\n# Retest assumptions\n# Diagnostic plots\nplot(fitted(test.fit.management), resid)\nabline(0,0)\n# QQ normal plot\nqqnorm(resid)\nqqline(resid)\n# derive PDF\nfixed.management<-fixed.effects(test.fit.management)\nmanagement.cov<-test.fit.management$varFix\n# variables\nx.rt.wet<-c(1, 1, 20, 15, 300, 1, 20, 15, 300, 300, 6000, 15, 300)\nx.rt.dry<-c(1, 1, 20, 15, 300, 0, 20, 15, 300, 300, 6000, 0, 0)\nx.nt.wet<-c(1, 0, 20, 15, 300, 1, 0, 0, 0, 300, 6000, 15, 300)\nx.nt.dry<-c(1, 0, 20, 15, 300, 0, 0, 0, 0, 300, 6000, 0, 0)\n# estimates\nt(x.rt.wet)%*%fixed.management\nt(x.rt.dry)%*%fixed.management\nt(x.nt.wet)%*%fixed.management\nt(x.nt.dry)%*%fixed.management\n# variance\nv.rt.wet<-(t(x.rt.wet)%*%management.cov%*%x.rt.wet)\nv.rt.dry<-(t(x.rt.dry)%*%management.cov%*%x.rt.dry)\nv.nt.wet<-(t(x.nt.wet)%*%management.cov%*%x.nt.wet)\nv.nt.dry<-(t(x.nt.dry)%*%management.cov%*%x.nt.dry)\n# standard deviation\nsqrt(v.rt.wet)\nsqrt(v.rt.dry)\nsqrt(v.nt.wet)\nsqrt(v.nt.dry)\n\n\n\n#making a matrix of the estimates\nestimates<-matrix(data = 0, nrow = 2, ncol = 2)\nrownames(estimates)<- c(\"rt\", \"nt\")\ncolnames(estimates)<- c(\"wet\", \"dry\")\n\nestimates[1,1]<-t(x.rt.wet)%*%fixed.management\nestimates[1,2]<-t(x.rt.dry)%*%fixed.management\nestimates[2,1]<-t(x.nt.wet)%*%fixed.management\nestimates[2,2]<-t(x.nt.dry)%*%fixed.management\nestimates\n\n#same thing for the variance\nvariance<-matrix(data = 0, nrow = 2, ncol = 2)\nrownames(variance)<- c(\"rt\", \"nt\")\ncolnames(variance)<- c(\"wet\", \"dry\")\n\nvariance[1,1]<-t(x.rt.wet)%*%management.cov%*%x.rt.wet\nvariance[1,2]<-t(x.rt.dry)%*%management.cov%*%x.rt.dry\nvariance[2,1]<-t(x.nt.wet)%*%management.cov%*%x.nt.wet\nvariance[2,2]<-t(x.nt.dry)%*%management.cov%*%x.nt.dry\nvariance\n\n\n#standard deviation\nsd<-sqrt(variance)\nsd\n\n\n\n#upper estimate and lower estimate\nlower.estimates<-estimates-1.96*sd\nupper.estimates<-estimates+1.96*sd\n\nlist(\"Mean.ch.cstock\"=Mean.ch.cstock,\n     \"Estimates.LME\"=estimates,\n     \"SDs.mean.ch.cstock\"=SD.ch.cstock,\n     \"SD.LME\"=sd,\n     \"lower.estimates.LME\"=lower.estimates,\n     \"upper.estimates.LME\"=upper.estimates)\n\n\n\nFunction\n\n\"SynFert.N2O.emissions.Regression\"<-\n  function(mineralN.amount = 75, mineralN.amount.sd = 5, beta = a, cov.beta = b, MAPPET = 1,\n           nreps = 10000, iseed = 230984, return.option = 1)\n# Script developed by: M. Carlson\n    # Originally developed: 3/2/2022\n    # Last updated:3/2/2022\n    # script estimates N2O emissions (kg CO2 eq. per ha per year) from mineral N fertilization\n    # based on LME model\n    # Note: Make sure that beta and cov.beta are loaded in R working session\n    #\n    ####### Arguments\n    # mineralN.amount       The amount of mineral N fertilizer added to soil (KG N per ha)\n    # mineralN.amount.sd    Standard deviation of the N mineral fertilizer amount\n    # MAPPET                Mean annual precipitation to potential evapotranspiration ratio\n    # beta                  R object with betas from LME model\n    # cov.beta              R object with covariance matrix for betas from LME model\n    # nreps                 Number of Monte Carlo simulations\n    # iseed                 Initial seed for random draws\n    # return.option         1) list object with the emission mean and confidence intervals\n    #                       for N2O emissions, and 2) the full vector of all Monte Carlo\n    #                       simulations.\n##\n####### Begin Script\n  {\n    ####### Set seed\n    set.seed(iseed)\n    ####### Check validity of input variables\n    # values equal to or greater than 0 are valid\n    check.mineralN.amount<-mineralN.amount>=0&mineralN.amount<=880\n    if(!check.mineralN.amount) {stop(\"Mineral N amount is not valid.\")\n    } else {cat(\"NOTE: Mineral N amount is valid.\")}\n    check.mineralN.amount.sd<-mineralN.amount.sd>=0\n    if(!check.mineralN.amount.sd) {stop(\"Mineral N standard deviation is not valid.\")\n    } else {cat(\"NOTE: Mineral N standard deviation is valid.\")}\n    check.MAPPET<-MAPPET>=0.7&MAPPET<=3.3\n    if(!check.MAPPET) {stop(\"MAP:PET ratio is not valid.\")\n    } else{cat(\"NOTE: MAP:PET ratio is valid.\")}\n    # End Validity checks\n    ##\n####### Estimate direct N2O emissions using linear mixed effect model.\n    # Deterministic Calculation\n    # estimate emissions and backtransform\n    direct.emission.deterministic.ln<-beta%*%t(cbind(1, mineralN.amount, MAPPET))\n    direct.emission.deterministic<-(exp(direct.emission.deterministic.ln))*(44/28)*298\n    # Probabilistic Calculation\n    # Simulate nreps of fertilizer amounts\n    mineralN.amount.sim <- rnorm(nreps, mean = mineralN.amount,\n                                 sd = mineralN.amount.sd)\n    # simulate nreps of beta parameters based on LME model\n    # determine number of parameters\n    numpar<-length(beta)\n    # Compute choleski decomposition\n    M<-t(chol(cov.beta))\n    #\n    # generate random normals\n    z<-matrix(rnorm(nreps*numpar), numpar, nreps)\n    # produce simulated betas\n    sim.beta<-M%*%z+beta\n    # create results matrix\n    direct.emission.sim.ln<-matrix(0, 1, nreps)\n    #simulate direct emissions\n    for (n in 1:nreps) {\n    direct.emission.sim.ln[n]<-sim.beta[,n]%*%t(cbind(1, mineralN.amount.sim[n], MAPPET))  \n    }\n    # backtransform and convert into kg CO2 eq.\n    direct.emission.sim<-(exp(direct.emission.sim.ln)) * (44/28) * 298\n    ## End emission calculations\n    #\n    ####### Final Summary Calculations and Validity Checks\n    direct.emission.mean<-mean(direct.emission.sim)\n    q.direct<-quantile(direct.emission.sim, probs = c(0.025, 0.975))\n    down.direct<-q.direct[1]\n    up.direct<-q.direct[2]\n    check.direct<-(direct.emission.deterministic>=down.direct) &\n                  (direct.emission.deterministic<=up.direct)\n    if(!check.direct) {\n      cat(\"Warning: Deterministic Solution for Direct Emissions is outside\n          of its respective confidence interval.\")\n    }\n    if(check.direct) {\n      cat(\"NOTE: Deterministic Solution for Direct Emissions is within\n          its respective confidence interval.\")\n    }\n    ##\n    #\n####### Return Statement\n    if(return.option == 1) {\n      return(list(\"direct.N2O.emissions.kgCO2eq\" = direct.emission.mean,\n                  \"2.5percentile.direct.N2O.emissions\" = down.direct,\n                  \"97.5percentile.direct.N2O.emissions\" = up.direct))\n    }\n    if(return.option == 2) {\n      return(direct.emission.sim)\n    } else {stop(\"Return option is not valid.\")}\n    #\n    #End return\n####### End Script    \n  }\n\n\n\nFitting N2O Model\n\n# Read data from csv file\nfert.n2o.data<-read.csv(\"FertN2Odata.csv\", header = T)\n# points (x = fert.n2o.data$fert.n2odata, y = fert.n2o.data$emission.kgN2ONhayr)\n# load nlme package\nlibrary(nlme)\n# test for correlation in predictor variables\ncor(fert.n2o.data[,c(\"fert.amt.kgha\", \"TEMP.C\", \"MAPPET\", \"PREC.MM\")])\n# Model Selection using AIC value and forward stepwise method\ntest.fit<-lme(emission.kgN2ONhayr~fert.amt.kgha, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n# Diagnostic Plots, Residual Plot\nresid<-residuals(test.fit)\nplot(fitted(test.fit), resid) # fitted vs residual plot\nabline(0,0)\n# qqplot cannot be tested due to lack of equality in variance\n\n# Transformed data\nfert.n2o.data$ln.emission.kgN2ONhayr<-log(fert.n2o.data$emission.kgN2ONhayr)\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n# Diagnostic Plots, Residual Plot\nresid<-residuals(test.fit)\nplot(fitted(test.fit), resid) # fitted vs residual plot\nabline(0,0)\n# QQ normal plot\nqqnorm(resid)\nqqline(resid)\n\n#One Variable\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\ntest.fit<-lme(ln.emission.kgN2ONhayr~TEMP.C, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\ntest.fit<-lme(ln.emission.kgN2ONhayr~MAPPET, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\ntest.fit<-lme(ln.emission.kgN2ONhayr~PREC.MM, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n\n# Two Variables\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+MAPPET, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+PREC.MM, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+TEMP.C, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n\n# Three Variables\n# don't need to test precip because it's highly correlated with MAPPET\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+MAPPET+TEMP.C, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n# Test interactions\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+MAPPET+fert.amt.kgha*MAPPET, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n\n\n\n# Best fit model\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+MAPPET, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n#\n# Extract betas and covariance matrix to apply the model\nN2O.fixed<-fixed.effects(test.fit)\nN2O.cov.beta<-test.fit$varFix\n##\n#\n\n\na = N2O.fixed\nb = N2O.cov.beta\n\n\n\nExecute Function\n\ndryclimate<-SynFert.N2O.emissions.Regression( mineralN.amount = 75, mineralN.amount.sd = 5, \n                                                beta = a, cov.beta = b, MAPPET = .7,\n                                            nreps = 10000, iseed = 230984, return.option = 1)\ndryclimate\n\ndryclimate2<-SynFert.N2O.emissions.Regression( mineralN.amount = 75, mineralN.amount.sd = 5, \n                                              beta = a, cov.beta = b, MAPPET = .7,\n                                              nreps = 10000, iseed = 230984, return.option = 2)\nhist(dryclimate2)\n\nwetclimate<-SynFert.N2O.emissions.Regression( mineralN.amount = 75, mineralN.amount.sd = 5, beta = a, \n                                                cov.beta = b, MAPPET = 1,\n                                                nreps = 10000, iseed = 230984, return.option = 1)\nwetclimate\n\nwetclimate2<-SynFert.N2O.emissions.Regression( mineralN.amount = 75, mineralN.amount.sd = 5, beta = a, \n                                              cov.beta = b, MAPPET = 1,\n                                              nreps = 10000, iseed = 230984, return.option = 2)\nhist(wetclimate2)"
  },
  {
    "objectID": "example.html",
    "href": "example.html",
    "title": "example",
    "section": "",
    "text": "this is a test"
  }
]