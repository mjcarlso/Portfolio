[
  {
    "objectID": "MonteCarlo.html",
    "href": "MonteCarlo.html",
    "title": "Advanced Monte Carlo",
    "section": "",
    "text": "Function\n\n\"SOC.function\"<-\n  function(SOC.ref = 80, SOC.ref.sd = 36, area = 56890, area.sd = 2844.5, expert.file = \"name\",\n           cult.beta.file = \"name\", mgmt.beta.file = \"name\", input.beta.file = \"name\", \n           cult.cov.file = \"name\", mgmt.cov.file = \"name\", input.cov.file = \"name\", \n           x.cult.file = \"name\", x.mgmt.file = \"name\", x.input.file = \"name\", nexpert = 9, \n           ncases = 6, strata = 1, d = 20, nreps = 10000, iseed = 230984, return.option=1, EF.ft = 1, EF.med.input = 1)\n# Script developed by M. Carlson\n# Originally developed: 9/27/2022\n# Last updated: \n# script estimates historical Soil Carbon \n# based on LME model that estimates emission factors\n#\n##### Arguments\n# reference soil carbon           from volcanic soils and warm temperate, moist\n# ref soil carbon uncertainty     + or - 90%\n# cropland area                   in ha\n# cropland area uncertainty       + or - 5%\n# d                               20 years\n# input data                      Expert data proportions\n# beta                            R object with betas from LME model\n# cov.beta                        R object with covariance matrix for betas from LME model\n# nreps                           Number of Monte Carlo simulations\n# iseed                           Initial seed for random draws\n# return.option            \n#\n##    \n##### Begin script\n  {\n##### Set seed\n    set.seed(iseed)\n    \n####### Import files\n    input.data<-read.csv(file = expert.file, header = F)\n    \n    cult.beta<-read.csv(file = cult.beta.file, header = F)\n    mgmt.beta<-read.csv(file = mgmt.beta.file, header = F)\n    input.beta<-read.csv(file = input.beta.file, header = F)\n    \n    cult.cov<-read.csv(file = cult.cov.file, header = F)\n    mgmt.cov<-read.csv(file = mgmt.cov.file, header = F)\n    input.cov<-read.csv(file = input.cov.file, header = F)\n    \n    x.cult<-read.csv(file = x.cult.file, header = F)\n    x.mgmt<-read.csv(file = x.mgmt.file, header = F)\n    x.input<-read.csv(file = x.input.file, header = F)\n    \n# ----------Probabilistic calculation ---------------\n\n####### Monte Carlo replicates\n    \n    ### simulate nreps of SOC ref\n    SOC.ref.sim<-rnorm(nreps, mean = SOC.ref, sd = SOC.ref.sd) \n    SOC.ref.sim<-as.matrix(t(SOC.ref.sim))\n    \n    # check that reps are inside 2 sd\n    check.soc.ref<-(SOC.ref.sim >= SOC.ref-(2*SOC.ref.sd)) &\n                   (SOC.ref.sim <= SOC.ref+(2*SOC.ref.sd))\n    if(!check.soc.ref){\n      stop(\"Warning: Simulated soil carbon reference is outside of expected range.\")\n    }\n    \n    ### simulate nreps of area\n    area.sim<-rnorm(nreps, mean = area, sd = area.sd) \n    \n    # check\n    check.area<-(area.sim >= area-(2*area.sd)) &\n                (area.sim <= area+(2*area.sd))\n    if(!check.area){\n      stop(\"Warning: Simulated area is outside of expected range.\")\n    }\n    \n    ### sample input data (2005 and 2020 together)\n    expert.draw<-input.data[sample(ncol(input.data), \n                                     size = nreps, replace = TRUE)]\n    # check\n    check.expert<-sum(expert.draw[,1]) == (2*strata)\n    if(!check.expert){\n      stop(\"Problem with expert proportions not summing to 100%\")\n    }\n    \n    # Combine area and expert proportion\n    area.prop.comb<-sweep(expert.draw, MARGIN=2, area.sim, `*`)\n    \n    # Check\n    check.prop.area<-area.prop.comb<=area\n    if(!check.prop.area){\n      stop(\"Proportion of area is not accurate\")\n    }\n    \n######## Emission Factor draws\n    \n    # turn into vectors\n    \n    cult.beta<-c(cult.beta[,1])\n    mgmt.beta<-c(mgmt.beta[,1])\n    input.beta<-c(input.beta[,1])\n    \n    x.cult<-c(x.cult[,1])\n    \n    x.mgmt.w.r<-c(x.mgmt[,1])\n    x.mgmt.w.n<-c(x.mgmt[,2])\n    x.mgmt.d.r<-c(x.mgmt[,3])\n    x.mgmt.d.n<-c(x.mgmt[,4])\n    \n    x.input.w.l<-c(x.input[,1])\n    x.input.w.h<-c(x.input[,2])\n    x.input.c.l<-c(x.input[,3])\n    x.input.c.h<-c(x.input[,4])\n    \n    # determine number of parameters\n    numpar.cult<-length(cult.beta)\n    numpar.mgmt<-length(mgmt.beta)\n    numpar.input<-length(input.beta)\n\n    # compute Choleski decomposition\n    decomp.cult<-t(chol(cult.cov))\n    decomp.mgmt<-t(chol(mgmt.cov))\n    decomp.input<-t(chol(input.cov))\n    \n    # generate random normals\n    r.cult<-matrix(rnorm(nreps*numpar.cult), numpar.cult, nreps)\n    r.mgmt<-matrix(rnorm(nreps*numpar.mgmt), numpar.mgmt, nreps)\n    r.input<-matrix(rnorm(nreps*numpar.input), numpar.input, nreps)\n    \n    # produce simulated betas\n    cult.sim.beta<-(decomp.cult%*%r.cult)+cult.beta\n    mgmt.sim.beta<-(decomp.mgmt%*%r.mgmt)+mgmt.beta\n    input.sim.beta<-(decomp.input%*%r.input)+input.beta\n    \n    \n######## Emission factors\n    \n    # cultivation\n    x.cult.beta<-sweep(cult.sim.beta, MARGIN=1, x.cult, `*`)\n    ef.cult<-apply(x.cult.beta[,1:nreps], 2, sum)\n    ef.cult<-as.matrix(t(ef.cult))\n    \n    # management\n    x.mgmt.w.r.beta<-sweep(mgmt.sim.beta, MARGIN=1, x.mgmt.w.r, `*`)\n    ef.mgmt.w.r<-apply(x.mgmt.w.r.beta[,1:nreps], 2, sum)\n    ef.mgmt.w.r<-as.matrix(t(ef.mgmt.w.r))\n    \n    x.mgmt.w.n.beta<-sweep(mgmt.sim.beta, MARGIN=1, x.mgmt.w.n, `*`)\n    ef.mgmt.w.n<-apply(x.mgmt.w.n.beta, 2, sum)\n    ef.mgmt.w.n<-as.matrix(t(ef.mgmt.w.n))\n    \n    x.mgmt.d.r.beta<-sweep(mgmt.sim.beta, MARGIN=1, x.mgmt.d.r, `*`)\n    ef.mgmt.d.r<-apply(x.mgmt.d.r.beta[,1:nreps], 2, sum)\n    ef.mgmt.d.r<-as.matrix(t(ef.mgmt.d.r))\n    \n    x.mgmt.d.n.beta<-sweep(mgmt.sim.beta, MARGIN=1, x.mgmt.d.n, `*`)\n    ef.mgmt.d.n<-apply(x.mgmt.d.n.beta[,1:nreps], 2, sum)\n    ef.mgmt.d.n<-as.matrix(t(ef.mgmt.d.n))\n    \n    # input\n    x.input.w.l.beta<-sweep(input.sim.beta, MARGIN=1, x.input.w.l, `*`)\n    ef.input.w.l<-apply(x.input.w.l.beta[,1:nreps], 2, sum)\n    ef.input.w.l<-as.matrix(t(ef.input.w.l))\n    \n    x.input.w.h.beta<-sweep(input.sim.beta, MARGIN=1, x.input.w.h, `*`)\n    ef.input.w.h<-apply(x.input.w.h.beta[,1:nreps], 2, sum)\n    ef.input.w.h<-as.matrix(t(ef.input.w.h))\n    \n    x.input.c.l.beta<-sweep(input.sim.beta, MARGIN=1, x.input.c.l, `*`)\n    ef.input.c.l<-apply(x.input.c.l.beta[,1:nreps], 2, sum)\n    ef.input.c.l<-as.matrix(t(ef.input.c.l))\n    \n    x.input.c.h.beta<-sweep(input.sim.beta, MARGIN=1, x.input.c.h, `*`)\n    ef.input.c.h<-apply(x.input.c.h.beta[,1:nreps], 2, sum)\n    ef.input.c.h<-as.matrix(t(ef.input.c.h))\n    \n\n####### -------------- Calculations -------------------------\n\n    ### Low input full till\n    SOC.l.f<-matrix(0, nrow = 1, ncol = nreps)\n    for (s in (1:nreps)) {\n      SOC.l.f[,s]<-((SOC.ref.sim[,s]*EF.ft*ef.cult[,s]*ef.input.w.l[,s]*area.prop.comb[7,s])-\n                    (SOC.ref.sim[,s]*EF.ft*ef.cult[,s]*ef.input.w.l[,s]*area.prop.comb[1,s]))/d\n    }\n    \n    ### Low input no till\n    SOC.l.n<-matrix(0, nrow = 1, ncol = nreps)\n    for (p in (1:nreps)) {\n      SOC.l.n[,p]<-((SOC.ref.sim[,p]*ef.cult[,p]*ef.input.w.l[,p]*ef.mgmt.w.n[,p]*area.prop.comb[8,p])-\n                    (SOC.ref.sim[,p]*ef.cult[,p]*ef.input.w.l[,p]*ef.mgmt.w.n[,p]*area.prop.comb[2,p]))/d\n    }\n    \n    ### Medium input full till\n    SOC.m.f<-matrix(0, nrow = 1, ncol = nreps)\n    for (q in (1:nreps)) {\n      SOC.m.f[,q]<-((SOC.ref.sim[,q]*EF.ft*ef.cult[,q]*EF.med.input*area.prop.comb[9,q])-\n                    (SOC.ref.sim[,q]*EF.ft*ef.cult[,q]*EF.med.input*area.prop.comb[3,q]))/d\n    }\n    \n    ### Medium input no till\n    SOC.m.n<-matrix(0, nrow = 1, ncol = nreps)\n    for (u in (1:nreps)) {\n      SOC.m.n[,u]<-((SOC.ref.sim[,u]*ef.cult[,u]*EF.med.input*ef.mgmt.w.n[,u]*area.prop.comb[10,u])-\n                    (SOC.ref.sim[,u]*ef.cult[,u]*EF.med.input*ef.mgmt.w.n[,u]*area.prop.comb[4,u]))/d\n    }\n    \n    ### High input full till\n    SOC.h.f<-matrix(0, nrow = 1, ncol = nreps)\n    for (v in (1:nreps)) {\n      SOC.h.f[,v]<-((SOC.ref.sim[,v]*EF.ft*ef.cult[,v]*ef.input.w.h[,v]*area.prop.comb[11,v])-\n                    (SOC.ref.sim[,v]*EF.ft*ef.cult[,v]*ef.input.w.h[,v]*area.prop.comb[5,v]))/d\n    }\n    \n    ### High input no till\n    SOC.h.n<-matrix(0, nrow = 1, ncol = nreps)\n    for (x in (1:nreps)) {\n      SOC.h.n[,x]<-((SOC.ref.sim[,x]*ef.cult[,x]*ef.input.w.h[,x]*ef.mgmt.w.n[,x]*area.prop.comb[12,x])-\n                    (SOC.ref.sim[,x]*ef.cult[,x]*ef.input.w.h[,x]*ef.mgmt.w.n[,x]*area.prop.comb[6,x]))/d\n    }\n    \n####### Total results\n    SOC.total<-matrix(0, nrow = 1, ncol = nreps)\n    for (t in (1:nreps)) {\n      SOC.total[,t]<-SOC.l.f[,t]+SOC.l.n[,t]+SOC.m.f[,t]+SOC.m.n[,t]+SOC.h.f[,t]+SOC.h.n[,t]\n    }\n    \n    \n####### Mean and Confidence Intervals    \n    results<-matrix(0, nrow = 1, ncol = 3)\n    results[,1]<-mean(SOC.total)\n    q<-quantile(SOC.total, probs = c(.025,.975))\n    results[,2]<-q[1]\n    results[,3]<-q[2]\n    \n######## -------------- Return options------------------------------\n    \n    if(return.option == 1){\n      return(list(\"Mean change in mineral soils C stock for Island X between\n                  2005 and 2020 (C tonnes/year)\" = results[,1], \"2.5 percentile\"\n                  = results[,2], \"97.5 percentile\" = results[,3]))\n    }\n    \n    if(return.option == 2){\n      return(hist(x=SOC.total, main = \"Simulated change in soil organic carbon.\"))\n    }\n  \n####### End script    \n  }\n\n\n\nFunction Call\n\nInventory<-SOC.function(expert.file = \"CropExpertProp.csv\", cult.beta.file = \"cult.beta.csv\",\n                        mgmt.beta.file = \"mgmt.beta.csv\", input.beta.file = \"input.beta.csv\", \n                        cult.cov.file = \"cult.cov.csv\", mgmt.cov.file = \"mgmt.cov.csv\",\n                        input.cov.file = \"input.cov.csv\", x.cult.file = \"x.cult.csv\",\n                        x.mgmt.file = \"x.mgmt.csv\", x.input.file = \"x.input.csv\", \n                        return.option=1)\n\nInventory2<-SOC.function(expert.file = \"CropExpertProp.csv\", cult.beta.file = \"cult.beta.csv\",\n                        mgmt.beta.file = \"mgmt.beta.csv\", input.beta.file = \"input.beta.csv\", \n                        cult.cov.file = \"cult.cov.csv\", mgmt.cov.file = \"mgmt.cov.csv\",\n                        input.cov.file = \"input.cov.csv\", x.cult.file = \"x.cult.csv\",\n                        x.mgmt.file = \"x.mgmt.csv\", x.input.file = \"x.input.csv\", \n                        return.option=2)\n  \n\nProjection2005.2025<-SOC.function(expert.file = \"Crop2025.csv\", cult.beta.file = \"cult.beta.csv\",\n                                    mgmt.beta.file = \"mgmt.beta.csv\", input.beta.file = \"input.beta.csv\", \n                                    cult.cov.file = \"cult.cov.csv\", mgmt.cov.file = \"mgmt.cov.csv\",\n                                    input.cov.file = \"input.cov.csv\", x.cult.file = \"x.cult.csv\",\n                                    x.mgmt.file = \"x.mgmt.csv\", x.input.file = \"x.input.csv\", \n                                    return.option=1)\n\nProjection2025.2040<-SOC.function(expert.file = \"Crop2040.csv\", cult.beta.file = \"cult.beta.csv\",\n                         mgmt.beta.file = \"mgmt.beta.csv\", input.beta.file = \"input.beta.csv\", \n                         cult.cov.file = \"cult.cov.csv\", mgmt.cov.file = \"mgmt.cov.csv\",\n                         input.cov.file = \"input.cov.csv\", x.cult.file = \"x.cult.csv\",\n                         x.mgmt.file = \"x.mgmt.csv\", x.input.file = \"x.input.csv\", \n                         return.option=1)"
  },
  {
    "objectID": "EmissionFactors.html",
    "href": "EmissionFactors.html",
    "title": "Estimate Emission Factors",
    "section": "",
    "text": "####### Libraries\nlibrary(nlme)\nlibrary(ggplot2)\n\n\n####### Data\n\nCultivation<-read.csv(\"SoilCCult.csv\")\nManagement<-read.csv(\"SoilCManagement.csv\")\nInput<-read.csv(\"SoilCInput.csv\")\n\n\n# ------------------------ Cultivation-------------------------------\n#Data Visualization\nggplot(Cultivation, aes(years))+\n  geom_histogram()\nggplot(Cultivation, aes(dep1))+\n  geom_histogram()\nggplot(Cultivation, aes(dep2))+\n  geom_histogram()\nggplot(Cultivation, aes(cult.stock))+\n  geom_histogram()\nggplot(Cultivation, aes(ch.cstock))+\n  geom_histogram()\nggplot(Cultivation, aes(nat.stock))+\n  geom_histogram()\nggplot(Cultivation, aes(x = ipcc.temp))+\n  geom_bar()\nggplot(Cultivation, aes(x = ipcc.soil))+\n  geom_bar()\nggplot(Cultivation, aes(x = ipcc.prec))+\n  geom_bar()\nggplot(Cultivation, aes(x = aquic))+\n  geom_bar()\n\n####### model\ncor(Management[c(\"years\", \"years2\", \"dep1\", \"dep2\")])\n\ntest.fit<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ipcc.soil+ipcc.prec,\n              random=~1|ran.exp/ran.yrexp,data=Cultivation,method=\"ML\",\n              na.action=na.omit)\nplot(test.fit)\nqqnorm(test.fit)\n\ntest.fit1<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ipcc.soil+ipcc.prec,\n              random=~1|ran.exp/ran.yrexp,data=Cultivation,method=\"ML\",\n              na.action=na.omit)\n\n# AIC Go up by two when removing variable (down by 2 when adding)\nsummary(test.fit1)\n\n# remove soil\ntest.fit1<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ipcc.prec,\n               random=~1|ran.exp/ran.yrexp,data=Cultivation,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit1)\n\n\n# Best model\ncult.fit<-lme(ch.cstock~years+years2+dep1+dep2,\n               random=~1|ran.exp/ran.yrexp,data=Cultivation,method=\"REML\",\n               na.action=na.omit)\nsummary(cult.fit)\n\n# pdf\nfixed.cult<-fixed.effects(cult.fit)\ncult.cov<-cult.fit$varFix\n\nfixed.cult\ncult.cov\n\nx.cult<-c(1, 75, 5625, 15, 300)\nt(x.cult)%*%fixed.cult\nv.cult<-(t(x.cult)%*%cult.cov%*%x.cult)\nsqrt(v.cult)\n\n\n# ------------------------ Input -------------------------------\n# Data Visualization\nggplot(Input, aes(years))+\n  geom_histogram()\nggplot(Input, aes(dep1))+\n  geom_histogram()\nggplot(Input, aes(dep2))+\n  geom_histogram()\nggplot(Input, aes(con.stock))+\n  geom_histogram()\nggplot(Input, aes(ch.cstock))+\n  geom_histogram()\nggplot(Input, aes(tr.stock))+\n  geom_histogram()\nggplot(Input, aes(x = ipcc.temp))+\n  geom_bar()\nggplot(Input, aes(x = ipcc.soil))+\n  geom_bar()\nggplot(Input, aes(x = ipcc.pre))+\n  geom_bar()\nggplot(Input, aes(x = ch.inp))+\n  geom_bar()\nggplot(Input, aes(x = aquic))+\n  geom_bar()\n\n\n####### model\ncor(Input[c(\"years\", \"years2\", \"dep1\", \"dep2\")])\n\ntest.fit2<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ipcc.pre+ch.inp,\n              random=~1|ran.exp/ran.yrexp,data=Input,method=\"ML\",\n              na.action=na.omit)\nplot(test.fit2)\nqqnorm(test.fit2)\n\nsummary(test.fit2)\n\n# remove precip\ntest.fit2<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ch.inp,\n               random=~1|ran.exp/ran.yrexp,data=Input,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit2)\n\n# remove temp (didn't go down enough)\ntest.fit2<-lme(ch.cstock~years+years2+dep1+dep2+ch.inp,\n               random=~1|ran.exp/ran.yrexp,data=Input,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit2)\n\n#### Best fit model\ninput.fit<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ch.inp,\n               random=~1|ran.exp/ran.yrexp,data=Input,method=\"REML\",\n               na.action=na.omit)\nsummary(input.fit)\n\n# pdf\nfixed.input<-fixed.effects(input.fit)\ninput.cov<-input.fit$varFix\n\nfixed.input\n\nwarm.low<-c(1, 20, 400, 15, 300, 1, 1)\nwarm.high<-c(1, 20, 400, 15, 300, 1, 0)\ncool.low<-c(1, 20, 400, 15, 300, 0, 1)\ncool.high<-c(1, 20, 400, 15, 300, 0, 0)\n\n#Estimates\nt(warm.low)%*%fixed.input\nt(warm.high)%*%fixed.input\nt(cool.low)%*%fixed.input\nt(cool.high)%*%fixed.input\n\n# variance\nv.warm.low<-(t(warm.low)%*%input.cov%*%warm.low)\nv.warm.high<-(t(warm.high)%*%input.cov%*%warm.high)\nv.cool.low<-(t(cool.low)%*%input.cov%*%cool.low)\nv.cool.high<-(t(cool.high)%*%input.cov%*%cool.high)\n\n# standard deviation\nsqrt(v.warm.low)\nsqrt(v.warm.high)\nsqrt(v.cool.low)\nsqrt(v.cool.high)\n\n\n# ---------------------------- Management --------------------------------\n# Data Visualization\nggplot(Management, aes(years))+\n  geom_histogram()\nggplot(Management, aes(dep1))+\n  geom_histogram()\nggplot(Management, aes(dep2))+\n  geom_histogram()\nggplot(Management, aes(con.stock))+\n  geom_histogram()\nggplot(Management, aes(ch.cstock))+\n  geom_histogram()\nggplot(Management, aes(tr.stock))+\n  geom_histogram()\nggplot(Management, aes(x = ipcc.temp))+\n  geom_bar()\nggplot(Management, aes(x = ipcc.soil))+\n  geom_bar()\nggplot(Management, aes(x = ipcc.pre))+\n  geom_bar()\nggplot(Management, aes(x = ch.till))+\n  geom_bar()\nggplot(Management, aes(x = aquic))+\n  geom_bar()\n\n\n####### model\ncor(Management[c(\"years\", \"years2\", \"dep1\", \"dep2\")])\n\ntest.fit3<-lme(ch.cstock~years2+ipcc.temp+ipcc.soil+ipcc.pre+years+dep1+dep2+aquic+ch.till,\n               random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n               na.action=na.omit)\nplot(test.fit3)\nqqnorm(test.fit3)\n\n\n# AIC Go up by two when removing variable (down by 2 when adding)\nsummary(test.fit3)\n\n# remove aquic\ntest.fit3<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.temp+ipcc.soil+ipcc.pre+ch.till,\n               random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit3)\n\n# remove soil\ntest.fit3<-lme(ch.cstock~years+years2+ipcc.pre+ipcc.temp+dep1+dep2+ch.till,\n               random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit3)\n\n# remove precip (keep it in)\ntest.fit3<-lme(ch.cstock~years+years2+ipcc.temp+dep1+dep2+ch.till,\n               random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit3)\n\n# remove temp\ntest.fit3<-lme(ch.cstock~years+years2+ipcc.pre+dep1+dep2+ch.till,\n               random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n               na.action=na.omit)\nsummary(test.fit3)\n\n# Best model\nmgmt.fit<-lme(ch.cstock~years+years2+dep1+dep2+ipcc.pre+ch.till,\n                         random=~1|ran.exp/ran.yrexp,data=Management,method=\"ML\",\n                         na.action=na.omit)\nsummary(mgmt.fit)\n\n\n# pdf\nfixed.mgmt<-fixed.effects(mgmt.fit)\nmgmt.cov<-mgmt.fit$varFix\n\nwet.rt<-c(1, 20, 400, 15, 300, 1, 1)\nwet.nt<-c(1, 20, 400, 15, 300, 1, 0)\ndry.rt<-c(1, 20, 400, 15, 300, 0, 1)\ndry.nt<-c(1, 20, 400, 15, 300, 0, 0)\n\n#Estimates\nt(wet.rt)%*%fixed.mgmt\nt(wet.nt)%*%fixed.mgmt\nt(dry.rt)%*%fixed.mgmt\nt(dry.nt)%*%fixed.mgmt\n\n# variance\nv.rt.wet<-(t(wet.rt)%*%mgmt.cov%*%wet.rt)\nv.nt.wet<-(t(wet.nt)%*%mgmt.cov%*%wet.nt)\nv.rt.dry<-(t(dry.rt)%*%mgmt.cov%*%dry.rt)\nv.nt.dry<-(t(dry.nt)%*%mgmt.cov%*%dry.nt)\n\n# standard deviation\nsqrt(v.rt.wet)\nsqrt(v.rt.dry)\nsqrt(v.nt.wet)\nsqrt(v.nt.dry)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Greenhouse Gas Accounting Portfolio",
    "section": "",
    "text": "------------------------------------------\n\n\nMasters in Ecosystem Science and Sustainability | Colorado State University 2021-2023\nBachelors in Environmental Studies | Kenyon College 2015 - 2019\n------------------------------------------\n\n\n\nGraduate Research Assistant National Parks Service | Climate Change Response Program 2022-2023"
  },
  {
    "objectID": "UreaEmissions.html",
    "href": "UreaEmissions.html",
    "title": "Urea Fertilization Emissions",
    "section": "",
    "text": "Function\nThis function was developed by M. Carlson\nOriginally developed: 8/25/2022\nLast updated:\nData used in this function is in\n\n\"Urea.Fert.Emisssions\"<-\n  function(input.file = \"name\", nyears = 31, states = 50, EF = .2, EF.min = .1,\n           EF.max = .2, nreps = 10000, iseed = 213456, return.option = 1)\n    # Input data converted from N to Urea\n    \n##### Begin script\n  {\n    # Seed seed\n    set.seed(iseed)\n    \n    ####### Import files\n    input.data<-read.csv(file = input.file)\n    \n    ####### Check Validity of Input Data\n    # Numeric\n    for (n in 1:(nyears*2)) {\n      input.data[,n+1]<-as.numeric(input.data[,n+1])\n    }\n    \n    # Urea Amounts\n    for (y in (1:nyears)){\n      for (t in (1:states)){\n    check.urea<-input.data[t,y+1]>0\n    if(!check.urea){stop(\"Error: Data is zero or negative.\")}\n      }\n    }\n    \n    # SD\n    for (y in (1:nyears)){\n      for (t in (1:states)){\n        check.sd<-input.data[t,y+1+nyears]>0\n        if(!check.sd){stop(\"Error: Data is zero or negative.\")}\n      }\n    }\n    \n    \n    ######## Deterministic results\n    Deterministic.CO2C<-matrix(0, nrow = states, ncol = nyears)\n    for(y in (1:nyears)){\n      for(d in (1:states)){\n        Deterministic.CO2C[d,y]<-(input.data[d,y+1]*EF)\n      }\n    }\n    \n    ##\n    Deterministic.CO2C.total<-apply(Deterministic.CO2C, MAR = 2, FUN = \"sum\")\n    Deterministic.CO2.total<-(Deterministic.CO2C.total*(44/12)/10^6)\n    Deterministic.CO2<-Deterministic.CO2C*(44/12)/10^6\n      \n    ######## Sim nreps \n    # EF\n    EF.sim<-rtriangle(nreps, a = EF.min, b = EF.max, c = EF)  \n    \n    \n    q.factor<-quantile(EF.sim, probs = c(.05,1))\n    down.factor<-q.factor[1]\n    up.factor<-q.factor[2]\n    \n    # Urea\n    urea.sim<-matrix(0, nrow = states*nyears, ncol = nreps)\n    for (y in (1:nyears)) {\n      for (t in (1:states)) {\n        urea.sim[t+(y-1)*50,]<-rnorm(n = nreps, mean = input.data[t, y+1], \n                                sd = input.data[t, y+1+nyears])\n      }\n    }\n    \n    ######## Probabilistic results\n    Probabilistic.CO2C<-matrix(0, nrow = states*nyears, ncol = nreps)\n    for (y in 1:nyears) {\n      for (s in 1:states) {\n        Probabilistic.CO2C[s+(states*(y-1)),]<-EF.sim*urea.sim[s+(states*(y-1)),]\n      }\n    }\n    \n    \n    # find mode\n    mode<-function(x){which.max(tabulate(x))}\n  \n    results.mode<-apply(Probabilistic.CO2C, 1, mode)\n    results.mode<-as.data.frame(results.mode)\n    \n    \n    \n    # Convert to Gg CO2\n    results.mode<-(results.mode*(44/12)/10^6)\n\n    # Make into readable df\n    State<-rep(c(\"Alabama\",\"Alaska\",\"Arizona\",\"Arkansas\",\"California\",\"Colorado\",\n             \"Connecticut\",\"Delaware\",\"Florida\",\"Georgia\",\"Hawaii\",\"Idaho\",\"Illinois\",\n             \"Indiana\",\"Iowa\",\"Kansas\",\"Kentucky\",\"Louisiana\",\"Maine\",\"Maryland\",\"Massachusetts\",\n             \"Michigan\",\"Minnesota\",\"Mississippi\",\"Missouri\",\"Montana\",\"Nebraska\",\"Nevada\",\n             \"New Hampsire\",\"New Jersey\",\"New Mexico\",\"New York\",\"North Carolina\",\"North Dakota\",\n             \"Ohio\",\"Oklahoma\",\"Oregon\",\"Pennsylvania\",\"Rhode Island\",\"South Carolina\",\n             \"South Dakota\",\"Tennessee\",\"Texas\",\"Utah\",\"Vermont\",\"Virginia\",\"Washington\",\"West Virginia\",\n             \"Wisconsin\",\"Wyoming\"),times=nyears)\n    results.mode$State<-data.frame(State)\n\n    newinput<-input.data[,1:32]\n    newinput<-newinput%>%\n      pivot_longer(!State, names_to = \"Year\", values_to = \"Urea\")\n    newinput<-newinput[order(newinput$Year),]\n    results.mode$xYear<-newinput$Year\n    \n    results.mode$emissions<-results.mode$results.mode\n    results.mode<-results.mode[,2:4]\n    \n    Probabilistic.CO2<-results.mode%>%\n      pivot_wider(names_from = \"xYear\", values_from = \"emissions\")\n    \n  mode2<-function(v, n=2){\n    v<-round(v,n)\n    u<-unique(v)\n    u[which.max(tabulate(match(v,u)))]\n  }\n    \n    \nProb.CO2C.state<-matrix(0, nrow = states*nyears, ncol = 3)\nfor (y in (1:(nyears*states))) {\n  Prob.CO2C.state[y,1]<-mode2(Probabilistic.CO2C[y,])\n  q<-quantile(Probabilistic.CO2C[y,], probs = c(.05,1))\n  Prob.CO2C.state[y,2]<-q[1]\n  Prob.CO2C.state[y,3]<-q[2]\n}\n\nProb.CO2.state<-(Prob.CO2C.state*(44/12)/10^6)\ncolnames(Prob.CO2.state)<-c(\"Mode\", \"5 Percentile\", \"100 Percentile\")\nrownames(Prob.CO2.state)<-State\nProb.CO2.state<-as.data.frame(Prob.CO2.state)\nProb.CO2.state$xYear<-newinput$Year\n\n  \n  \n    ##### Total probabilistic  per year\n    \n    Probabilistic.CO2C.total.US<-matrix(0, nrow = nyears, ncol = nreps)\n    for (y in (1:nyears)){\n     Probabilistic.CO2C.total.US[y,]<-apply(Probabilistic.CO2C[(1+(50*(y-1))):(50+(50*(y-1))),], MARG = 2, FUN = \"sum\")\n    }\n    \n    Total.emissions.results.CO2C<-matrix(0, nrow = nyears, ncol = 3)\n    for (y in (1:nyears)) {\n     Total.emissions.results.CO2C[y,1]<-mode2(Probabilistic.CO2C.total.US[y,1]) \n     q<-quantile(Probabilistic.CO2C.total.US[y,1], probs = c(.05,1))\n     Total.emissions.results.CO2C[y,2]<-q[1]\n     Total.emissions.results.CO2C[y,3]<-q[2]\n    }\n    \n    Total.emissions.results<-(Total.emissions.results.CO2C*(44/12)/10^6)\n    colnames(Total.emissions.results)<-c(\"Mode\", \"5 Percentile\", \"100 Percentile\")\n    rownames(Total.emissions.results)<-c(1990:2020)\n    \n    ######## Check that probabilistic is less than or equal to deterministic\n    # per state per year\n   # for (y in (1:nyears)){\n   #   for (t in (1:states)){\n    #    check.results<-Probabilistic.CO2[t,y]<=Deterministic.CO2[t,y]\n     #   if(!check.results){stop(\"Error: Probabilistic emissions are too high.\")}}}\n    \n    # per country per year\n    #for (y in (1:nyears)){\n     #   check.results.total<-Probabilistic.CO2.total[,y]<=Deterministic.CO2.total[,y]\n      #  if(!check.results.total){stop(\"Error: Total probabilistic emissions for the \n       #                               country are too high.\")}}\n    \n    ######## Return Statement\n    if(return.option == 1){\n      return(Total.emissions.results)\n    }\n    if(return.option == 2){\n      return(Prob.CO2.state)\n    }\n    if(return.option == 3){\n      return(Deterministic.CO2)\n    }\n    \n    \n###### End script\n    }\n\n\n\nResult Exploration\n\nTotal.Emissions.year<-Urea.Fert.Emisssions(input.file = \"data/US-Urea1990-2020.csv\", return.option = 1)\nhead(Total.Emissions.year)\n\n         Mode 5 Percentile 100 Percentile\n1990 4.184332     4.184332       4.184332\n1991 4.011988     4.011988       4.011988\n1992 4.292598     4.292598       4.292598\n1993 4.571429     4.571429       4.571429\n1994 4.641019     4.641019       4.641019\n1995 4.588808     4.588808       4.588808"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "MineralFert.html",
    "href": "MineralFert.html",
    "title": "Mineral Fertilization Emissions",
    "section": "",
    "text": "Model Fit\n\n# Regression analysis using linear mixed effect model\n# load nlme package\nlibrary(nlme)\n####### Management Factor\n# Read data from csv file\nmanagement.data<-read.csv(\"SoilCManagement.csv\", header = T)\n# Test for correlation in predictor variables\ncor(management.data[, c(\"years\", \"dep1\", \"dep2\")])\n# Fit full model with all variables as main effects for input\ntest.fit<-lme(ch.cstock~ch.till+years+years2+dep1+dep2+moisture+temp,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n# Diagnostic Plots, Residual Plot\nresid<-residuals(test.fit)\nplot(fitted(test.fit), resid)\nabline(0,0)\n# QQ normal plot\nqqnorm(resid)\nqqline(resid)\n# Full model\ntest.fit<-lme(ch.cstock~ch.till+years+years2+dep1+dep2+moisture+temp,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n# Backward stepwise method\n# remove year2\ntest.fit<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture+temp,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n#remove tempwarm\ntest.fit<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n# Testing interactions\ntest.fit<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture+ch.till*years+ch.till*dep1+\n                ch.till*dep2+ch.till*moisture+years*dep1+years*dep2+years*moisture+\n                dep1*moisture+dep2*moisture,\n                random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n                na.action = na.omit)\nsummary(test.fit)\n# remove year and moisture interaction\ntest.fit<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture+ch.till*years+ch.till*dep1+\n                ch.till*dep2+ch.till*moisture+years*dep1+years*dep2+\n                dep1*moisture+dep2*moisture,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n# remove tillage and moisture interaction\ntest.fit<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture+ch.till*years+ch.till*dep1+\n                ch.till*dep2+years*dep1+years*dep2+\n                dep1*moisture+dep2*moisture,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"ML\",\n              na.action = na.omit)\nsummary(test.fit)\n# final model\ntest.fit.management<-lme(ch.cstock~ch.till+years+dep1+dep2+moisture+ch.till*years+ch.till*dep1+\n                ch.till*dep2+years*dep1+years*dep2+\n                dep1*moisture+dep2*moisture,\n              random=~1|ran.exp/ran.yrexp, data = management.data, method = \"REML\",\n              na.action = na.omit)\nsummary(test.fit.management)\n# Retest assumptions\n# Diagnostic plots\nplot(fitted(test.fit.management), resid)\nabline(0,0)\n# QQ normal plot\nqqnorm(resid)\nqqline(resid)\n# derive PDF\nfixed.management<-fixed.effects(test.fit.management)\nmanagement.cov<-test.fit.management$varFix\n# variables\nx.rt.wet<-c(1, 1, 20, 15, 300, 1, 20, 15, 300, 300, 6000, 15, 300)\nx.rt.dry<-c(1, 1, 20, 15, 300, 0, 20, 15, 300, 300, 6000, 0, 0)\nx.nt.wet<-c(1, 0, 20, 15, 300, 1, 0, 0, 0, 300, 6000, 15, 300)\nx.nt.dry<-c(1, 0, 20, 15, 300, 0, 0, 0, 0, 300, 6000, 0, 0)\n# estimates\nt(x.rt.wet)%*%fixed.management\nt(x.rt.dry)%*%fixed.management\nt(x.nt.wet)%*%fixed.management\nt(x.nt.dry)%*%fixed.management\n# variance\nv.rt.wet<-(t(x.rt.wet)%*%management.cov%*%x.rt.wet)\nv.rt.dry<-(t(x.rt.dry)%*%management.cov%*%x.rt.dry)\nv.nt.wet<-(t(x.nt.wet)%*%management.cov%*%x.nt.wet)\nv.nt.dry<-(t(x.nt.dry)%*%management.cov%*%x.nt.dry)\n# standard deviation\nsqrt(v.rt.wet)\nsqrt(v.rt.dry)\nsqrt(v.nt.wet)\nsqrt(v.nt.dry)\n\n\n\n#making a matrix of the estimates\nestimates<-matrix(data = 0, nrow = 2, ncol = 2)\nrownames(estimates)<- c(\"rt\", \"nt\")\ncolnames(estimates)<- c(\"wet\", \"dry\")\n\nestimates[1,1]<-t(x.rt.wet)%*%fixed.management\nestimates[1,2]<-t(x.rt.dry)%*%fixed.management\nestimates[2,1]<-t(x.nt.wet)%*%fixed.management\nestimates[2,2]<-t(x.nt.dry)%*%fixed.management\nestimates\n\n#same thing for the variance\nvariance<-matrix(data = 0, nrow = 2, ncol = 2)\nrownames(variance)<- c(\"rt\", \"nt\")\ncolnames(variance)<- c(\"wet\", \"dry\")\n\nvariance[1,1]<-t(x.rt.wet)%*%management.cov%*%x.rt.wet\nvariance[1,2]<-t(x.rt.dry)%*%management.cov%*%x.rt.dry\nvariance[2,1]<-t(x.nt.wet)%*%management.cov%*%x.nt.wet\nvariance[2,2]<-t(x.nt.dry)%*%management.cov%*%x.nt.dry\nvariance\n\n\n#standard deviation\nsd<-sqrt(variance)\nsd\n\n\n\n#upper estimate and lower estimate\nlower.estimates<-estimates-1.96*sd\nupper.estimates<-estimates+1.96*sd\n\nlist(\"Mean.ch.cstock\"=Mean.ch.cstock,\n     \"Estimates.LME\"=estimates,\n     \"SDs.mean.ch.cstock\"=SD.ch.cstock,\n     \"SD.LME\"=sd,\n     \"lower.estimates.LME\"=lower.estimates,\n     \"upper.estimates.LME\"=upper.estimates)\n\n\n\nFunction\n\n\"SynFert.N2O.emissions.Regression\"<-\n  function(mineralN.amount = 75, mineralN.amount.sd = 5, beta = a, cov.beta = b, MAPPET = 1,\n           nreps = 10000, iseed = 230984, return.option = 1)\n# Script developed by: M. Carlson\n    # Originally developed: 3/2/2022\n    # Last updated:3/2/2022\n    # script estimates N2O emissions (kg CO2 eq. per ha per year) from mineral N fertilization\n    # based on LME model\n    # Note: Make sure that beta and cov.beta are loaded in R working session\n    #\n    ####### Arguments\n    # mineralN.amount       The amount of mineral N fertilizer added to soil (KG N per ha)\n    # mineralN.amount.sd    Standard deviation of the N mineral fertilizer amount\n    # MAPPET                Mean annual precipitation to potential evapotranspiration ratio\n    # beta                  R object with betas from LME model\n    # cov.beta              R object with covariance matrix for betas from LME model\n    # nreps                 Number of Monte Carlo simulations\n    # iseed                 Initial seed for random draws\n    # return.option         1) list object with the emission mean and confidence intervals\n    #                       for N2O emissions, and 2) the full vector of all Monte Carlo\n    #                       simulations.\n##\n####### Begin Script\n  {\n    ####### Set seed\n    set.seed(iseed)\n    ####### Check validity of input variables\n    # values equal to or greater than 0 are valid\n    check.mineralN.amount<-mineralN.amount>=0&mineralN.amount<=880\n    if(!check.mineralN.amount) {stop(\"Mineral N amount is not valid.\")\n    } else {cat(\"NOTE: Mineral N amount is valid.\")}\n    check.mineralN.amount.sd<-mineralN.amount.sd>=0\n    if(!check.mineralN.amount.sd) {stop(\"Mineral N standard deviation is not valid.\")\n    } else {cat(\"NOTE: Mineral N standard deviation is valid.\")}\n    check.MAPPET<-MAPPET>=0.7&MAPPET<=3.3\n    if(!check.MAPPET) {stop(\"MAP:PET ratio is not valid.\")\n    } else{cat(\"NOTE: MAP:PET ratio is valid.\")}\n    # End Validity checks\n    ##\n####### Estimate direct N2O emissions using linear mixed effect model.\n    # Deterministic Calculation\n    # estimate emissions and backtransform\n    direct.emission.deterministic.ln<-beta%*%t(cbind(1, mineralN.amount, MAPPET))\n    direct.emission.deterministic<-(exp(direct.emission.deterministic.ln))*(44/28)*298\n    # Probabilistic Calculation\n    # Simulate nreps of fertilizer amounts\n    mineralN.amount.sim <- rnorm(nreps, mean = mineralN.amount,\n                                 sd = mineralN.amount.sd)\n    # simulate nreps of beta parameters based on LME model\n    # determine number of parameters\n    numpar<-length(beta)\n    # Compute choleski decomposition\n    M<-t(chol(cov.beta))\n    #\n    # generate random normals\n    z<-matrix(rnorm(nreps*numpar), numpar, nreps)\n    # produce simulated betas\n    sim.beta<-M%*%z+beta\n    # create results matrix\n    direct.emission.sim.ln<-matrix(0, 1, nreps)\n    #simulate direct emissions\n    for (n in 1:nreps) {\n    direct.emission.sim.ln[n]<-sim.beta[,n]%*%t(cbind(1, mineralN.amount.sim[n], MAPPET))  \n    }\n    # backtransform and convert into kg CO2 eq.\n    direct.emission.sim<-(exp(direct.emission.sim.ln)) * (44/28) * 298\n    ## End emission calculations\n    #\n    ####### Final Summary Calculations and Validity Checks\n    direct.emission.mean<-mean(direct.emission.sim)\n    q.direct<-quantile(direct.emission.sim, probs = c(0.025, 0.975))\n    down.direct<-q.direct[1]\n    up.direct<-q.direct[2]\n    check.direct<-(direct.emission.deterministic>=down.direct) &\n                  (direct.emission.deterministic<=up.direct)\n    if(!check.direct) {\n      cat(\"Warning: Deterministic Solution for Direct Emissions is outside\n          of its respective confidence interval.\")\n    }\n    if(check.direct) {\n      cat(\"NOTE: Deterministic Solution for Direct Emissions is within\n          its respective confidence interval.\")\n    }\n    ##\n    #\n####### Return Statement\n    if(return.option == 1) {\n      return(list(\"direct.N2O.emissions.kgCO2eq\" = direct.emission.mean,\n                  \"2.5percentile.direct.N2O.emissions\" = down.direct,\n                  \"97.5percentile.direct.N2O.emissions\" = up.direct))\n    }\n    if(return.option == 2) {\n      return(direct.emission.sim)\n    } else {stop(\"Return option is not valid.\")}\n    #\n    #End return\n####### End Script    \n  }\n\n\n\nFitting N2O Model\n\n# Read data from csv file\nfert.n2o.data<-read.csv(\"FertN2Odata.csv\", header = T)\n# points (x = fert.n2o.data$fert.n2odata, y = fert.n2o.data$emission.kgN2ONhayr)\n# load nlme package\nlibrary(nlme)\n# test for correlation in predictor variables\ncor(fert.n2o.data[,c(\"fert.amt.kgha\", \"TEMP.C\", \"MAPPET\", \"PREC.MM\")])\n# Model Selection using AIC value and forward stepwise method\ntest.fit<-lme(emission.kgN2ONhayr~fert.amt.kgha, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n# Diagnostic Plots, Residual Plot\nresid<-residuals(test.fit)\nplot(fitted(test.fit), resid) # fitted vs residual plot\nabline(0,0)\n# qqplot cannot be tested due to lack of equality in variance\n\n# Transformed data\nfert.n2o.data$ln.emission.kgN2ONhayr<-log(fert.n2o.data$emission.kgN2ONhayr)\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n# Diagnostic Plots, Residual Plot\nresid<-residuals(test.fit)\nplot(fitted(test.fit), resid) # fitted vs residual plot\nabline(0,0)\n# QQ normal plot\nqqnorm(resid)\nqqline(resid)\n\n#One Variable\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\ntest.fit<-lme(ln.emission.kgN2ONhayr~TEMP.C, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\ntest.fit<-lme(ln.emission.kgN2ONhayr~MAPPET, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\ntest.fit<-lme(ln.emission.kgN2ONhayr~PREC.MM, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n\n# Two Variables\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+MAPPET, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+PREC.MM, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+TEMP.C, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n\n# Three Variables\n# don't need to test precip because it's highly correlated with MAPPET\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+MAPPET+TEMP.C, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n# Test interactions\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+MAPPET+fert.amt.kgha*MAPPET, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n\n\n\n# Best fit model\ntest.fit<-lme(ln.emission.kgN2ONhayr~fert.amt.kgha+MAPPET, random = ~1|ran.exp, \n              data = fert.n2o.data, method = \"ML\")\nsummary(test.fit)\n#\n# Extract betas and covariance matrix to apply the model\nN2O.fixed<-fixed.effects(test.fit)\nN2O.cov.beta<-test.fit$varFix\n##\n#\n\n\na = N2O.fixed\nb = N2O.cov.beta\n\n\n\nExecute Function\n\ndryclimate<-SynFert.N2O.emissions.Regression( mineralN.amount = 75, mineralN.amount.sd = 5, \n                                                beta = a, cov.beta = b, MAPPET = .7,\n                                            nreps = 10000, iseed = 230984, return.option = 1)\ndryclimate\n\ndryclimate2<-SynFert.N2O.emissions.Regression( mineralN.amount = 75, mineralN.amount.sd = 5, \n                                              beta = a, cov.beta = b, MAPPET = .7,\n                                              nreps = 10000, iseed = 230984, return.option = 2)\nhist(dryclimate2)\n\nwetclimate<-SynFert.N2O.emissions.Regression( mineralN.amount = 75, mineralN.amount.sd = 5, beta = a, \n                                                cov.beta = b, MAPPET = 1,\n                                                nreps = 10000, iseed = 230984, return.option = 1)\nwetclimate\n\nwetclimate2<-SynFert.N2O.emissions.Regression( mineralN.amount = 75, mineralN.amount.sd = 5, beta = a, \n                                              cov.beta = b, MAPPET = 1,\n                                              nreps = 10000, iseed = 230984, return.option = 2)\nhist(wetclimate2)"
  },
  {
    "objectID": "example.html",
    "href": "example.html",
    "title": "example",
    "section": "",
    "text": "this is a test"
  },
  {
    "objectID": "GreenTransport.html",
    "href": "GreenTransport.html",
    "title": "Green Transportation",
    "section": "",
    "text": "# read in csv's and check data\n\nAge<-read.csv(\"AgeClasses.csv\")\nEducation<-read.csv(\"Education.csv\")\nEmissions<-read.csv(\"Emissions per Mile.csv\")\nGender<-read.csv(\"Gender.csv\")\nSurvey<-read.csv(\"SurveyResults.csv\")\nTrip<-read.csv(\"TripPurpose.csv\")\nTradeIn<-read.csv(\"Vehicle_Trade_in.csv\")\nType<-read.csv(\"VehicleType.csv\")\n\nlibrary(tidyverse)\nlibrary(purrr)\nlibrary(plyr)\n\n# Join together some data\nTypeSurvey<-full_join(Survey, Type)\ncolnames(TypeSurvey)[9] <- \"Vehicle_Type\"\nSurveyEmissions<-full_join(TypeSurvey,Emissions, by = \"Vehicle_Type\")\nSurveyEmissions<-full_join(SurveyEmissions, Gender)\nSurveyEmissions<-full_join(SurveyEmissions, Education)\nSurveyEmissions<-full_join(SurveyEmissions, Age)\n\n# Daily emissions in MT\nSurveyEmissions$DailyEmissions<-SurveyEmissions$miles*SurveyEmissions$NumberOfTrips*\n                                  SurveyEmissions$kg.CO2.per.mile/1000\n# Annual\nSurveyEmissions$AnnualEmissions<-SurveyEmissions$DailyEmissions*313\n\n# Strata trends\nAgeAvg<-SurveyEmissions%>%\n  group_by(AgeCode)%>%\n  summarise_at(vars(DailyEmissions), list(name = mean))\nAgeAvg\n\nGenderAvg<-SurveyEmissions%>%\n  group_by(GenderCode)%>%\n  summarise_at(vars(DailyEmissions), list(name = mean))\nGenderAvg\n\nEducationAvg<-SurveyEmissions%>%\n  group_by(EducationCode)%>%\n  summarise_at(vars(DailyEmissions), list(name = mean))\nEducationAvg\n\nVehicleAvg<-SurveyEmissions%>%\n  group_by(Vehicle_Type)%>%\n  summarise_at(vars(DailyEmissions), list(name = mean))\nVehicleAvg\n\nPurposeAvg<-SurveyEmissions%>%\n  group_by(TripPurposeCode)%>%\n  summarise_at(vars(DailyEmissions), list(name = mean))\nPurposeAvg\n\n\n# DF with just buy back vehicles\nBuyBack<-SurveyEmissions%>%\n  filter(VehicleTypeCode == \"SU\" | VehicleTypeCode == \"TR\" | VehicleTypeCode == \"SE\")\n  \n# Check averages of buy back\nAgeAvg2<-BuyBack%>%\n  group_by(AgeCode)%>%\n  summarise_at(vars(DailyEmissions), list(name = mean))\nAgeAvg2\n\nGenderAvg2<-BuyBack%>%\n  group_by(GenderCode)%>%\n  summarise_at(vars(DailyEmissions), list(name = mean))\nGenderAvg2\n\nEducationAvg2<-BuyBack%>%\n  group_by(EducationCode)%>%\n  summarise_at(vars(DailyEmissions), list(name = mean))\nEducationAvg2\n\nPurposeAvg2<-BuyBack%>%\n  group_by(TripPurposeCode)%>%\n  summarise_at(vars(DailyEmissions), list(name = mean))\nPurposeAvg2\n\n# add price of buy back\ncolnames(TradeIn)[1] <- \"Vehicle_Type\"\n\nBuyBack<-full_join(BuyBack, TradeIn)\n\n# weekly emissions (I am making the assumption that people drive the same amount \n# on the weekend as they do during the week. While some people might not drive at all, many\n# people will likely be traveling more to get to recreational activities in the mountains.\n# I am making the assumption that these two behaviors will average out to weekday travel amounts.)\n# Assuming 2 weeks of vacation\nBuyBack$WeeklyEmissions<-BuyBack$DailyEmissions*7\n\n# What if EV\nBuyBack$IfEVDaily<-BuyBack$miles*BuyBack$NumberOfTrips*0.21/1000\nBuyBack$IfEVWeekly<-BuyBack$IfEVDaily*7\nBuyBack$EVAnnual<-BuyBack$IfEVDaily*313\n\nBuyBack$Reduction<-BuyBack$WeeklyEmissions-BuyBack$IfEVWeekly\nBuyBack$AnnualReduction<-BuyBack$AnnualEmissions-BuyBack$EVAnnual\n\nnreps = 1000\n\n# ----------------------- Weekly ----------------------\n# Vehicle type probability\nsampType<-function(){\n  test<-sample(BuyBack$ID.x, size = 108, replace = FALSE, prob = BuyBack$Pr_BuyBack_VehicleType)\n  test<-as.data.frame(test)\n  colnames(test)[1]<-\"ID.x\"\n  \n  test<-left_join(test, BuyBack)\n  \n  testcost<-sum(test$Cost)\n  testchange<-sum(test$Reduction)\n  results<-matrix(0, nrow = 1, ncol = 2)\n  results[1,1]<-testcost\n  results[1,2]<-testchange\n  print(results)\n}\n\nfor (a in nreps) {\n  results<-rerun(nreps, sampType())\n  resultsType<-ldply(results, data.frame)\n}\n\n\n# Mean and CI\n#Type\nmeanType<-mean(resultsType[,2])\nmcType<-mean(resultsType[,1])\nTypeQe<-quantile(resultsType[,2], probs = c(.025,.975))\nTypeQc<-quantile(resultsType[,1], probs = c(.025,.975))\n\n\n# Weekly cost\ntypecost<-mcType/meanType\n\n\n# ------------------ Annual -------------\nsampTypeA<-function(){\n  test<-sample(BuyBack$ID.x, size = 107, replace = FALSE, prob = BuyBack$Pr_BuyBack_VehicleType)\n  test<-as.data.frame(test)\n  colnames(test)[1]<-\"ID.x\"\n  \n  test<-left_join(test, BuyBack)\n  \n  testcost<-sum(test$Cost)\n  testchange<-sum(test$AnnualReduction)\n  results<-matrix(0, nrow = 1, ncol = 2)\n  results[1,1]<-testcost/testchange\n  results[1,2]<-testchange\n  print(results)\n}\n\n\nfor (a in nreps) {\n  results<-rerun(nreps, sampTypeA())\n  resultsType<-ldply(results, data.frame)\n}\n\n\n# Age probability\nsampAgeA<-function(){\n  test<-sample(BuyBack$ID.x, size = 107, replace = FALSE, prob = BuyBack$Pr_BuyBack_Age)\n  test<-as.data.frame(test)\n  colnames(test)[1]<-\"ID.x\"\n  \n  test<-left_join(test, BuyBack)\n  \n  testcost<-sum(test$Cost)\n  testchange<-sum(test$AnnualReduction)\n  results<-matrix(0, nrow = 1, ncol = 2)\n  results[1,1]<-testcost/testchange\n  results[1,2]<-testchange\n  print(results)\n}\n\nfor (a in nreps) {\n  results<-rerun(nreps, sampAgeA())\n  resultsAge<-ldply(results, data.frame)\n}\n\n\n# Education probability\nsampEducationA<-function(){\n  test<-sample(BuyBack$ID.x, size = 107, replace = FALSE, prob = BuyBack$Pr_BuyBack_Education)\n  test<-as.data.frame(test)\n  colnames(test)[1]<-\"ID.x\"\n  \n  test<-left_join(test, BuyBack)\n  \n  testcost<-sum(test$Cost)\n  testchange<-sum(test$AnnualReduction)\n  results<-matrix(0, nrow = 1, ncol = 2)\n  results[1,1]<-testcost/testchange\n  results[1,2]<-testchange\n  print(results)\n}\n\nfor (a in nreps) {\n  results<-rerun(nreps, sampEducationA())\n  resultsEducation<-ldply(results, data.frame)\n}\n\n# Gender probability\nsampGenderA<-function(){\n  test<-sample(BuyBack$ID.x, size = 107, replace = FALSE, prob = BuyBack$Pr_BuyBack_Gender)\n  test<-as.data.frame(test)\n  colnames(test)[1]<-\"ID.x\"\n  \n  test<-left_join(test, BuyBack)\n  \n  testcost<-sum(test$Cost)\n  testchange<-sum(test$AnnualReduction)\n  results<-matrix(0, nrow = 1, ncol = 2)\n  results[1,1]<-testcost/testchange\n  results[1,2]<-testchange\n  print(results)\n}\n\nfor (a in nreps) {\n  results<-rerun(nreps, sampGenderA())\n  resultsGender<-ldply(results, data.frame)\n}\n\n# Mean and CI\n#Type\nmeanTypeA<-mean(resultsType[,2])\nmcTypeA<-mean(resultsType[,1])\nTypeQeA<-quantile(resultsType[,2], probs = c(.025,.975))\nTypeQcA<-quantile(resultsType[,1], probs = c(.025,.975))\n\n#Age\nmeanAgeA<-mean(resultsAge[,2])\nmcAgeA<-mean(resultsAge[,1])\nAgeQeA<-quantile(resultsAge[,2], probs = c(.025,.975))\nAgeQcA<-quantile(resultsAge[,1], probs = c(.025,.975))\n\n#Education\nmeanEducationA<-mean(resultsEducation[,2])\nmcEducationA<-mean(resultsEducation[,1])\nEducationQeA<-quantile(resultsEducation[,2], probs = c(.025,.975))\nEducationQcA<-quantile(resultsEducation[,1], probs = c(.025,.975))\n\n#Gender\nmeanGenderA<-mean(resultsGender[,2])\nmcGenderA<-mean(resultsGender[,1])\nGenderQeA<-quantile(resultsGender[,2], probs = c(.025,.975))\nGenderQcA<-quantile(resultsGender[,1], probs = c(.025,.975))\n\n\n# -------------------- SUV --------------------------------\n\nSUV<-BuyBack%>%\n  filter(Vehicle_Type == \"SUV\")\n\n# 90 vehicles\n\n\nsampSUV<-function(){\n  test<-sample(SUV$ID.x, size = 90, replace = FALSE)\n  test<-as.data.frame(test)\n  colnames(test)[1]<-\"ID.x\"\n  \n  test<-left_join(test, SUV)\n  \n  testcost<-sum(test$Cost)\n  testchange<-sum(test$AnnualReduction)\n  results<-matrix(0, nrow = 1, ncol = 2)\n  results[1,1]<-testcost/testchange\n  results[1,2]<-testchange\n  print(results)\n}\n\nfor (a in nreps) {\n  results<-rerun(nreps, sampSUV())\n  resultsSUV<-ldply(results, data.frame)\n}\n\n# SUV mean and cost\nmeanSUV<-mean(resultsSUV[,2])\nmcSUV<-mean(resultsSUV[,1])\nSUVQe<-quantile(resultsSUV[,2], probs = c(.025,.975))\nSUVQc<-quantile(resultsSUV[,1], probs = c(.025,.975))\n\n\n\n# Sedan\n\nSedan<-BuyBack%>%\n  filter(Vehicle_Type == \"Sedan\")\n\n# 125 vehicles\n\n\nsampSedan<-function(){\n  test<-sample(Sedan$ID.x, size = 125, replace = FALSE)\n  test<-as.data.frame(test)\n  colnames(test)[1]<-\"ID.x\"\n  \n  test<-left_join(test, Sedan)\n  \n  testcost<-sum(test$Cost)\n  testchange<-sum(test$AnnualReduction)\n  results<-matrix(0, nrow = 1, ncol = 2)\n  results[1,1]<-testcost/testchange\n  results[1,2]<-testchange\n  print(results)\n}\n\nfor (a in nreps) {\n  results<-rerun(nreps, sampSedan())\n  resultsSedan<-ldply(results, data.frame)\n}\n\n# SUV mean and cost\nmeanSedan<-mean(resultsSedan[,2])\nmcSedan<-mean(resultsSedan[,1])\nSedanQe<-quantile(resultsSedan[,2], probs = c(.025,.975))\nSedanQc<-quantile(resultsSedan[,1], probs = c(.025,.975))\n\n\n# Truck\n\nTruck<-BuyBack%>%\n  filter(Vehicle_Type == \"Truck\")\n\n# 110 vehicles\n\n\nsampTruck<-function(){\n  test<-sample(Truck$ID.x, size = 110, replace = FALSE)\n  test<-as.data.frame(test)\n  colnames(test)[1]<-\"ID.x\"\n  \n  test<-left_join(test, Truck)\n  \n  testcost<-sum(test$Cost)\n  testchange<-sum(test$AnnualReduction)\n  results<-matrix(0, nrow = 1, ncol = 2)\n  results[1,1]<-testcost/testchange\n  results[1,2]<-testchange\n  print(results)\n}\n\nfor (a in nreps) {\n  results<-rerun(nreps, sampTruck())\n  resultsTruck<-ldply(results, data.frame)\n}\n\n# SUV mean and cost\nmeanTruck<-mean(resultsTruck[,2])\nmcTruck<-mean(resultsTruck[,1])\nTruckQe<-quantile(resultsTruck[,2], probs = c(.025,.975))\nTruckQc<-quantile(resultsTruck[,1], probs = c(.025,.975))\n\n\n# read in csv's and check data\nEmissions<-read.csv(\"Emissions per Mile.csv\")\nSurvey<-read.csv(\"SurveyResults.csv\")\nType<-read.csv(\"VehicleType.csv\")\n\n\nlibrary(tidyverse)\n\n# Join together some data\nTypeSurvey<-full_join(Survey, Type)\ncolnames(TypeSurvey)[9] <- \"Vehicle_Type\"\nWC<-full_join(TypeSurvey,Emissions, by = \"Vehicle_Type\")%>%\n  filter(TripPurposeCode == \"WC\")%>%\n  filter(!Vehicle_Type == \"Large Truck\")\n\n\n# Businesses DF\ns<-data.frame(\"ID\"=1:11503, \"Type\"=\"S\", \"Min\"=1, \"Max\"=10, \"propTC\"=.009, \"probPart\"=.09)\nm<-data.frame(\"ID\"=11504:15157, \"Type\"=\"M\", \"Min\"=11, \"Max\"=30, \"propTC\"=.031, \"probPart\"=.12)\nl<-data.frame(\"ID\"=15158:15660, \"Type\"=\"L\", \"Min\"=31, \"Max\"=50, \"propTC\"=.064, \"probPart\"=.17)\n\nbusinesses<-rbind(s,m,l)\n\n# 100 companies can participate\n\n# nested for loop, select business then select number of people within each business\n\n\n# sample emission data using quantiles of number of people decided from nested for loop \n# (can use replacement)\n# or sample the results from the for loop\n# no differentiated probability\n# subtract people already work commuting\n\n\nnreps = 1000\nm<-matrix(0, nrow = 100, ncol = 1)\nw<-matrix(0, nrow = 100, ncol = 1)\npeople<-matrix(0, nrow = nreps, ncol = 1)\nfor (a in 1:nreps) {\n  mn<-sample(businesses$ID, size = 100, replace = F, prob = businesses$probPart)\n  join<-businesses[businesses$ID %in% mn,]\n  for (b in 1:100) {\n    m[b,]<-sample(join[b,3]:join[b,4], size = 1)\n    w<-m-join[b,5]*m\n    w<-round(w)\n  }\n  people[a,1]<-sum(w)\n}\n\n\n# find emissions\n\n# Daily emissions in MT\nWC$DailyEmissions<-WC$miles*WC$NumberOfTrips*WC$kg.CO2.per.mile/1000\n# Just work week (with two weeks of vacay)\nWC$AnnualEmissions<-WC$DailyEmissions*250\n# Assume 2 days from home\nWC$AnnualWFH2<-WC$DailyEmissions*150\nWC$AnnualWFH3<-WC$DailyEmissions*100\nWC$AnnualWFH4<-WC$DailyEmissions*50\nWC$AnnualWFH5<-0\n\n\n# sample from Work Commuters\n\n# 2 days at home\nreduced2<-matrix(0, nrow = nreps, ncol = 2)\nfor (c in 1:nreps) {\n  samp<-sample(WC$ID.x, size = people[c,], replace = T)\n  samp<-as.data.frame(samp)\n  colnames(samp)[1]<-\"ID.x\"\n  samp<-left_join(samp, WC, .keep_all =TRUE)\n  reduced2[c,1]<-sum(samp[,14])-sum(samp[,15])\n  reduced2[c,2]<-500000/(sum(samp[,14])-sum(samp[,15]))\n}\n\nmean2emissions<-mean(reduced2[,1])\nq2emissions<-quantile(reduced2[,1], probs = c(.025,.975))\nmean2cost<-mean(reduced2[,2])\nq2cost<-quantile(reduced2[,2], probs = c(.025,.975))\n\n\n# 3 days at home\nreduced3<-matrix(0, nrow = nreps, ncol = 2)\nfor (c in 1:nreps) {\n  samp<-sample(WC$ID.x, size = people[c,], replace = T)\n  samp<-as.data.frame(samp)\n  colnames(samp)[1]<-\"ID.x\"\n  samp<-left_join(samp, WC, .keep_all =TRUE)\n  reduced3[c,1]<-sum(samp[,14])-sum(samp[,16])\n  reduced3[c,2]<-500000/(sum(samp[,14])-sum(samp[,16]))\n}\n\nmean3emissions<-mean(reduced3[,1])\nq3emissions<-quantile(reduced3[,1], probs = c(.025,.975))\nmean3cost<-mean(reduced3[,2])\nq3cost<-quantile(reduced3[,2], probs = c(.025,.975))\n\n\n# 4 days at home\nreduced4<-matrix(0, nrow = nreps, ncol = 2)\nfor (c in 1:nreps) {\n  samp<-sample(WC$ID.x, size = people[c,], replace = T)\n  samp<-as.data.frame(samp)\n  colnames(samp)[1]<-\"ID.x\"\n  samp<-left_join(samp, WC, .keep_all =TRUE)\n  reduced4[c,1]<-sum(samp[,14])-sum(samp[,17])\n  reduced4[c,2]<-500000/(sum(samp[,14])-sum(samp[,17]))\n}\n\nmean4emissions<-mean(reduced4[,1])\nq4emissions<-quantile(reduced4[,1], probs = c(.025,.975))\nmean4cost<-mean(reduced4[,2])\nq4cost<-quantile(reduced4[,2], probs = c(.025,.975))\n\n\n# 5 days a week\nreduced5<-matrix(0, nrow = nreps, ncol = 2)\nfor (c in 1:nreps) {\n  samp<-sample(WC$ID.x, size = people[c,], replace = T)\n  samp<-as.data.frame(samp)\n  colnames(samp)[1]<-\"ID.x\"\n  samp<-left_join(samp, WC, .keep_all =TRUE)\n  reduced5[c,1]<-sum(samp[,14])-sum(samp[,18])\n  reduced5[c,2]<-500000/(sum(samp[,14])-sum(samp[,18]))\n}\n\nmean5emissions<-mean(reduced5[,1])\nq5emissions<-quantile(reduced5[,1], probs = c(.025,.975))\nmean5cost<-mean(reduced5[,2])\nq5cost<-quantile(reduced5[,2], probs = c(.025,.975))"
  },
  {
    "objectID": "Transport.html",
    "href": "Transport.html",
    "title": "Transportation Emissions",
    "section": "",
    "text": "CO2 Emission Function\n\n\"CO2TransportEmissions\"<-\n  function(CO2.EF = 69300, fuel.amount = 10000)\n    # Script developed by M. Carlson\n    # Originally Developed: February 11, 2022\n    # Last Updated: February 11, 2022\n    # Script estimated CO2 emissions from road transportation using default equations from\n    # 2006 IPCC guidelines\n    # Results are in MMT CO2\n    #\n    ####### Arguments\n    # CO2.EF             CO2 emission factor in kg/TJ\n    # fuel.amount        Amount of fuel in TJ\n    #\n    ####### Start Script\n  {\n    #######Check Validity of Input Data\n    # Check that input fuel data are valid\n    check.fuel.amount<-fuel.amount>0\n    if(!check.fuel.amount)  {stop(\"The amount of fuel must be greater than 0.\")\n    }\n    # Check that EF is valid\n    check.CO2.EF<-CO2.EF>0\n    if(!check.CO2.EF)  {stop(\"The emission factor must be greater than 0.\")\n      }\n    #\n    ####### Estimate CO2 emissions\n    # IPCC 2006 GL: CO2 emissions = fuel.amount * EF\n    # Units: CO2 emissions are in kg, fuel.amount is in TJ, and EF is in kg/TJ\n    CO2.emissions.kg<-fuel.amount*CO2.EF\n    #\n    # convert into MMT\n    CO2.emissions.MMT<-CO2.emissions.kg/10^9\n    #\n    ####### Check results\n    check.emisison.amount<-CO2.emissions.MMT>0\n    if(!check.emisison.amount)  {stop(\"The amount of emissions must be greater than 0.\")\n    }\n    #\n    ####### Return Statement\n    return(list(\"CO2.emissions.MMT\" = CO2.emissions.MMT))\n    #\n    ####### End Script\n  }\n\n\n\nOther GHG Emissions Function\n\n\"CH4N2OTransportEmissions\"<-\n  function(input.filename = \"NAME\", vehicle.type = 1)\n    # Script developed by M. Carlson\n    # Originally Developed: February 16, 2022\n    # Last Updated: February 16, 2022\n    # Script estimates CH4 and N2O emissions from road transportation using default equations\n    # from 2006 IPCC guidelines\n    #\n    ####### Arguements\n    # input.file          Name of file with activity data, which is a comma delimited file\n    #                     with the emissions factors and input\n    #                     activity data in columns along with header row as follows:\n    #                     vehicle type, fuel amount (TJ), CH4 emission factor (kg/TJ),\n    #                     and N2O emission factor (lg/TJ).\n    # vehicle.type        Number of vehicle types in the input file\n    # #\n    ####### Begin script\n    {\n    ####### Import files\n    #getwd()\n    input.data<-read.csv(file = input.filename, header = T, sep = \",\", fill = F)\n    #\n    ####### Check number of vehicle types in input file\n    check.type<-length(input.data[,1])==vehicle.type\n    if(!check.type) {stop(\"The number of vehicles types in the input file is not \n                          consistent withthe number entered in the function argument.\")\n      }\n    #\n    ####### Check Validity of Input Data\n    for (f in (1:vehicle.type)){\n      check.fuel.amount<-input.data[f,3]>0\n      if(!check.fuel.amount){stop(\"Fuel amount must be greater than 0 - Check input file.\")\n      }\n      check.CH4.ef<-input.data[f,4]>0\n      if(!check.CH4.ef){stop(\"Methane EF must be greater than 0 - Check input file.\")\n      }\n      check.N2O.ef<-input.data[f,5]>0\n      if(!check.N2O.ef){stop(\"Nitrous oxide EF must be greater than 0 - Check input file.\")\n      } \n    }\n    #\n    ####### Calculate emission\n    # IPCC 2006 GL: CH4 emissions = Fuel.amount * EF\n    # Units: CH4 emissions in kg, Fuel.amount in TJ and EF is kg/TJ\n    #\n    CH4.emissions.kg<-vector(mode = \"numeric\", length = vehicle.type)\n    for (ch in (1:vehicle.type)) {\n      CH4.emissions.kg[ch]<-input.data[ch,3]*input.data[ch,4]\n      # Check Emissions\n      check.CH4.emission.kg<-CH4.emissions.kg[ch]>0&CH4.emissions.kg[ch]<=10^12\n      if(!check.CH4.emission.kg){cat(\"Warning: Methane emissions are not within the expected range.\")\n      }\n    }\n    # IPCC 2006 GL: N2O emissions = Fuel.amount * EF\n    N2O.emissions.kg<-vector(mode = \"numeric\", length = vehicle.type)\n    for (n2o in (1:vehicle.type)) {\n      N2O.emissions.kg[n2o]<-input.data[n2o,3]*input.data[n2o,5]\n      # Check Emissions\n      check.N2O.emission.kg<-N2O.emissions.kg[n2o]>0&N2O.emissions.kg[n2o]<=10^12\n      if(!check.N2O.emission.kg){cat(\"Warning: Methane emissions are not within the expected range.\")\n      }\n    }\n    # Total emissions in CO2 eq.\n    Total.CH4.TMT.CO2e<-(sum(CH4.emissions.kg)/10^6)*25\n    Total.N2O.TMT.CO2e<-(sum(CH4.emissions.kg)/10^6)*298\n    Total.CH4.N2O.MMT.CO2e<-(Total.CH4.TMT.CO2e+Total.N2O.TMT.CO2e)/10^3\n    #\n    ####### Return Statement\n    return(list(\"Total.CH4.TMT.CO2e\" = Total.CH4.TMT.CO2e,\n                \"Total.N2O.TMT.CO2e\" = Total.N2O.TMT.CO2e,\n                \"Total.CH4.N2O.MMT.CO2e\" = Total.CH4.N2O.MMT.CO2e))\n    #\n    ####### End script\n  }"
  }
]